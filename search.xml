<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>js基础系列(一):数组相关</title>
      <link href="/2019/09/08/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-%E4%B8%80-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/09/08/js%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97-%E4%B8%80-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一-常用数组方法"><a href="#一-常用数组方法" class="headerlink" title="一,常用数组方法"></a>一,常用数组方法</h1><h2 id="1-1-arr-map"><a href="#1-1-arr-map" class="headerlink" title="1-1 arr.map()"></a>1-1 arr.map()</h2><blockquote><p>此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5]let newArr = arr.map(x =&gt; x*2)console.log(arr);       //arr= [1, 2, 3, 4, 5]   原数组保持不变console.log(newArr);    //newArr = [2, 4, 6, 8, 10] 返回新数组</code></pre><h2 id="1-2-arr-forEach"><a href="#1-2-arr-forEach" class="headerlink" title="1-2 arr.forEach()"></a>1-2 arr.forEach()</h2><blockquote><p>此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和map方法区分</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5]num.forEach(x =&gt; x*2)   // arr = [2, 4, 6, 8, 10]  数组改变,注意和map区分</code></pre><h2 id="1-3-arr-filter"><a href="#1-3-arr-filter" class="headerlink" title="1-3 arr.filter()"></a>1-3 arr.filter()</h2><blockquote><p>此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5]let isBigEnough =&gt; value =&gt; value &gt;= 3let newArr = arr.filter(isBigEnough )    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组</code></pre><h2 id="1-4-arr-push-new"><a href="#1-4-arr-push-new" class="headerlink" title="1-4 arr.push(new)"></a>1-4 arr.push(new)</h2><blockquote><p>此方法是在数组的后面添加新加元素，此方法改变了数组的长度</p></blockquote><pre><code>let arr = [1,2]arr.push(3)console.log(arr) //[1,2,3x]</code></pre><h2 id="1-5-arr-pop"><a href="#1-5-arr-pop" class="headerlink" title="1-5 arr.pop()"></a>1-5 arr.pop()</h2><blockquote><p>此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5]    arr.pop()    console.log(arr) //[1, 2, 3, 4]    console.log(arr.length) //4</code></pre><h2 id="1-6-arr-shift"><a href="#1-6-arr-shift" class="headerlink" title="1-6 arr.shift()"></a>1-6 arr.shift()</h2><blockquote><p>此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5]    arr.shift()    console.log(arr) //[2, 3, 4, 5]    console.log(arr.length) //4 </code></pre><h2 id="1-7-arr-unshift"><a href="#1-7-arr-unshift" class="headerlink" title="1-7 arr.unshift()"></a>1-7 arr.unshift()</h2><blockquote><p>此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5]    arr.unshift(6, 7)    console.log(arr) //[6, 7, 2, 3, 4, 5]    console.log(arr.length) //7 </code></pre><h2 id="1-8-arr-isArray"><a href="#1-8-arr-isArray" class="headerlink" title="1-8 arr.isArray()"></a>1-8 arr.isArray()</h2><blockquote><p>判断一个对象是不是数组，返回的是布尔值</p></blockquote><pre><code>let arr = [1,2]Array.isArray(arr) // true</code></pre><h2 id="1-9-arr-concat"><a href="#1-9-arr-concat" class="headerlink" title="1-9 arr.concat()"></a>1-9 arr.concat()</h2><blockquote><p>此方法是一个可以将多个数组拼接成一个数组</p></blockquote><pre><code>let arr1 = [1, 2, 3],    arr2 = [4, 5]  let arr = arr1.concat(arr2)  console.log(arr)//[1, 2, 3, 4, 5]</code></pre><h2 id="1-10-arr-toString"><a href="#1-10-arr-toString" class="headerlink" title="1-10 arr.toString()"></a>1-10 arr.toString()</h2><blockquote><p>此方法将数组转化为字符串</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5];let str = arr.toString()   console.log(str)// 1,2,3,4,5let str1 = arr.toString()let str2 = arr.toString(&#39;,&#39;)let str3 = arr.toString(&#39;##&#39;)   console.log(str1)// 12345   console.log(str2)// 1,2,3,4,5   console.log(str3)// 1##2##3##4##5</code></pre><h2 id="1-11-arr-join"><a href="#1-11-arr-join" class="headerlink" title="1-11 arr.join()"></a>1-11 arr.join()</h2><blockquote><p>此方法也是将数组转化为字符串</p></blockquote><pre><code>let arr = [1, 2, 3, 4, 5];arr.join(&#39;-&#39;) //1-2-3-4-5</code></pre><h2 id="1-12-arr-splice-开始位置，-删除的个数，元素"><a href="#1-12-arr-splice-开始位置，-删除的个数，元素" class="headerlink" title="1-12 arr.splice(开始位置， 删除的个数，元素)"></a>1-12 arr.splice(开始位置， 删除的个数，元素)</h2><blockquote><p>　万能方法，可以实现增删改，然后返回被删除的项目。。注意：该方法会改变原始数组</p></blockquote><pre><code>//1.新增元素let a = [1, 2, 3, 4, 5];let a1 =  a.splice(2, 0, &#39;haha&#39;)console.log(a) //[1, 2, &#39;haha&#39;, 3, 4, 5]新增一个元素console.log(a1) //[]  返回被删除的项目// 2.删除元素let b = [1, 2, 3, 4, 5];let b1 =  b.splice(2, 3)console.log(b); // [1,2]console.log(b1) //[3, 4, 5]// 3.替换元素let c = [1, 2, 3, 4, 5];let c1 =  c.splice(2, 1,&#39;haha&#39;)console.log(c); // [ 1, 2, &#39;haha&#39;, 4, 5 ]console.log(c1) //[3]</code></pre><h2 id="1-13-arr-slice"><a href="#1-13-arr-slice" class="headerlink" title="1-13 arr.slice()"></a>1-13 arr.slice()</h2><blockquote><p>splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。</p></blockquote><pre><code>let arr = [1,2,3,4,5,6]let newArr = arr.slice(1,2)console.log(newArr); //[ 2 ]console.log(arr); //[ 1, 2, 3, 4, 5, 6 ]</code></pre><p>##1-14  arr.sort()</p><blockquote><p>按照 Unicode code 位置排序，默认升序</p></blockquote><pre><code>let arr = [21,12,3,4,5,6]arr.sort()console.log(arr); //[21,12,3,4,5,6]</code></pre><ul><li>升序</li></ul><pre><code>let arr = [21,12,3,44,5,6]arr.sort((a,b)=&gt;{    return a-b})console.log(arr); //[ 3, 5, 6, 12, 21, 44 ]</code></pre><ul><li>降序</li></ul><pre><code>let arr = [21,12,3,44,5,6]arr.sort((a,b)=&gt;{    return b-a})console.log(arr); //[ 44, 21, 12, 6, 5, 3 ]</code></pre><p>##1-15 arr.reverse()</p><blockquote><p>reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组。</p></blockquote><pre><code>let arr = [21,12,3,44,5,6]arr.reverse()console.log(arr); //[ 6, 5, 44, 3, 12, 21 ]</code></pre><h2 id="1-16-indexOf-和-lastIndexOf"><a href="#1-16-indexOf-和-lastIndexOf" class="headerlink" title="1-16 indexOf 和 lastIndexOf"></a>1-16 indexOf 和 lastIndexOf</h2><blockquote><p>都是查找数组元素 出现的位置。都接受两个参数：查找的值、查找起始位置<br>不存在，返回 -1 ；存在，返回位置。</p><p>indexOf 是从前往后查找， lastIndexOf 是从后往前查找。</p></blockquote><pre><code>let arr = [21,12,3,44,5,6]console.log(arr.indexOf(12)); //1</code></pre><h1 id="二-es6新增的数组操作"><a href="#二-es6新增的数组操作" class="headerlink" title="二,es6新增的数组操作"></a>二,es6新增的数组操作</h1><h2 id="2-1-reduce"><a href="#2-1-reduce" class="headerlink" title="2-1 reduce()"></a>2-1 reduce()</h2><p>语法</p><pre><code>arr.reduce(function(prev,cur,index,arr){...}, init);</code></pre><p><strong>arr</strong> 表示原数组；<br><strong>prev</strong> 表示上一次调用回调时的返回值，或者初始值 init;<br><strong>cur</strong> 表示当前正在处理的数组元素；<br><strong>index</strong> 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；<br><strong>init</strong> 表示初始值。</p><h3 id="2-1-1-数组求和"><a href="#2-1-1-数组求和" class="headerlink" title="2-1-1 数组求和"></a>2-1-1 数组求和</h3><pre><code>let arr = [1,2,3,1,2]getSum = (all,now) =&gt; {    return  all + now}let sum = arr.reduce(getSum)console.log(`sum=${sum}`);  // sum=9</code></pre><h3 id="2-1-2-数组求最大值"><a href="#2-1-2-数组求最大值" class="headerlink" title="2-1-2 数组求最大值"></a>2-1-2 数组求最大值</h3><pre><code>let arr = [1,2,3,1,2]getMax = (a,b) =&gt; {    return Math.max(a,b)}let max = arr.reduce(getMax)console.log(`max=${max}`); // max=3</code></pre><h3 id="2-1-3-数组去重"><a href="#2-1-3-数组去重" class="headerlink" title="2-1-3 数组去重"></a>2-1-3 数组去重</h3><pre><code>let arr = [1,2,3,1,2]getOnlyOne = (total,cur) =&gt; {    total.indexOf(cur) === -1 &amp;&amp; total.push(cur)    return total}let newArr = arr.reduce(getOnlyOne,[])console.log(newArr); // [1,2,3]</code></pre><h2 id="2-2-arr-every"><a href="#2-2-arr-every" class="headerlink" title="2-2 arr.every()"></a>2-2 arr.every()</h2><blockquote><p>定义和用法</p></blockquote><p>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p><p>every() 方法使用指定函数检测数组中的所有元素：</p><ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回 <em>false</em> ，且剩余的元素不会再进行检测。</li><li><strong>如果所有元素都满足条件，则返回 true</strong>。</li></ul><p><strong>注意：</strong> every() 不会对空数组进行检测。</p><p><strong>注意：</strong> every() 不会改变原始数组。</p><ul><li>语法</li></ul><pre><code>语法：array.every(function(item,index,array）{               //item:当前元素的值；                    //index:当前元素的索引；                    // array:当前元素的数组对象；                })</code></pre><ul><li>用法</li></ul><pre><code>let a = [1,2,3,4].every((item)=&gt;{return item &gt; 5})console.log(a) // falselet b = [1,2,3,4].every((item)=&gt;{return item &gt; 2})console.log(b) // falselet c = [1,2,3,4].every((item)=&gt;{return item &gt;= 1})console.log(c) // true</code></pre><h2 id="2-3-arr-some"><a href="#2-3-arr-some" class="headerlink" title="2-3 arr.some()"></a>2-3 arr.some()</h2><blockquote><p>定义和用法</p></blockquote><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p><p>some() 方法会依次执行数组的每个元素：</p><ul><li><strong>如果有一个元素满足条件，则表达式返回<em>true</em></strong> , 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回false。</li></ul><p><strong>注意：</strong> some() 不会对空数组进行检测。</p><p><strong>注意：</strong> some() 不会改变原始数组。</p><ul><li>语法</li></ul><pre><code>语法：array.some(function(item,index,array){                    //item:当前元素的值；                    //index:当前元素的索引；                    // array:当前元素的数组对象；                })</code></pre><ul><li>用法</li></ul><pre><code>let a = [1,2,3,4].some((item)=&gt;{return item&gt;5})console.log(a) // falselet b = [1,2,3,4].some((item)=&gt;{return item&lt;2})console.log(b) // truelet c = [1,2,3,4].some((item)=&gt;{return item&lt;1})console.log(c) // false</code></pre><p>##2-4 arr.filfter()</p><blockquote><p>定义和用法</p></blockquote><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><p><strong>注意：</strong> filter() 不会对空数组进行检测。</p><p><strong>注意：</strong> filter() 不会改变原始数组。</p><pre><code>let arr = [21,12,3,44,5,6]let a = arr.filter((item)=&gt;{    return item &gt; 10})console.log(a); //[ 21, 12, 44 ]console.log(arr); //[ 21, 12, 3, 44, 5, 6 ]</code></pre><h2 id="2-5-arr-map"><a href="#2-5-arr-map" class="headerlink" title="2-5 arr.map()"></a>2-5 arr.map()</h2><blockquote><p>定义和用法</p></blockquote><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p>map() 方法按照原始数组元素顺序依次处理元素。</p><p><strong>注意：</strong> map() 不会对空数组进行检测。</p><p><strong>注意：</strong> map() 不会改变原始数组。返回每次函数调用的结果组成一个新数组</p><blockquote><p>语法</p></blockquote><pre><code>array.map(function(currentValue,index,arr), thisValue)</code></pre><ul><li>currentValue   必须。当前元素的值</li><li>index                可选。当前元素的索引值</li><li>arr                    可选。当前元素属于的数组对象</li></ul><blockquote><p>用法</p></blockquote><pre><code>let arr = [21,12,3,44,5,6]let a = arr.map((item)=&gt;{    return item &gt; 10})console.log(a); //[ true, true, false, true, false, false ]console.log(arr); //[ 21, 12, 3, 44, 5, 6 ]</code></pre><h2 id="2-6-arr-find"><a href="#2-6-arr-find" class="headerlink" title="2-6 arr.find()"></a>2-6 arr.find()</h2><blockquote><p>定义和用法</p></blockquote><p>find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p><p>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回 <em>true</em> 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li><li>如果没有符合条件的元素返回 undefined</li></ul><p><strong>注意:</strong> find() 对于空数组，函数是不会执行的。</p><p><strong>注意:</strong> find() 并没有改变数组的原始值。</p><blockquote><p>语法</p></blockquote><pre><code>array.find(function(currentValue, index, arr),thisValue)</code></pre><ul><li>currentValue   必须。当前元素的值</li><li>index                可选。当前元素的索引值</li><li>arr                    可选。当前元素属于的数组对象</li></ul><blockquote><p>用法</p></blockquote><pre><code>let arr = [4,22,3,44,5,6]let a = arr.find((item)=&gt;{    return item &gt; 10})console.log(a); //2console.log(arr); //[ 4, 22, 3, 44, 5, 6 ]</code></pre><h2 id="2-7-arr-findIndex"><a href="#2-7-arr-findIndex" class="headerlink" title="2-7 arr.findIndex()"></a>2-7 arr.findIndex()</h2><blockquote><p>定义和用法</p></blockquote><p>findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p><p>findIndex() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回 <em>true</em> 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</li><li>如果没有符合条件的元素返回 -1</li></ul><p><strong>注意:</strong> findIndex() 对于空数组，函数是不会执行的。</p><p><strong>注意:</strong> findIndex() 并没有改变数组的原始值。</p><blockquote><p>语法</p></blockquote><pre><code>array.findIndex(function(currentValue, index, arr), thisValue)</code></pre><blockquote><p>用法</p></blockquote><pre><code>let arr = [4,22,3,44,5,6]let a = arr.findIndex((item)=&gt;{    return item &gt; 10})console.log(a); //1console.log(arr); //[ 4, 22, 3, 44, 5, 6 ]</code></pre><h2 id="2-8-arr-entries"><a href="#2-8-arr-entries" class="headerlink" title="2-8 arr.entries()"></a>2-8 arr.entries()</h2><p>entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。</p><p>迭代对象中数组的索引值作为 key， 数组元素作为 value。</p><pre><code>let arr = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for(let item of arr.entries()){    console.log(item); }/*[ 0, &#39;Banana&#39; ][ 1, &#39;Orange&#39; ][ 2, &#39;Apple&#39; ][ 3, &#39;Mango&#39; ] */</code></pre><h2 id="2-9-arr-values"><a href="#2-9-arr-values" class="headerlink" title="2-9 arr.values()"></a>2-9 arr.values()</h2><p>返回迭代器：返回键值对的value。（对比参考arr.entries()）</p><pre><code>let arr = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for(let item of arr.values()){    console.log(item); }/** BananaOrangeAppleMango */</code></pre><h2 id="2-10-arr-keys"><a href="#2-10-arr-keys" class="headerlink" title="2-10 arr.keys()"></a>2-10 arr.keys()</h2><p>keys() 方法用于从数组创建一个包含数组键的可迭代对象。</p><p>如果对象是数组返回 true，否则返回 false。</p><pre><code>let arr = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];for(let item of arr.keys()){    console.log(item); }/**0123 */</code></pre><h1 id="三-数组去重"><a href="#三-数组去重" class="headerlink" title="三.数组去重"></a>三.数组去重</h1><p>主要介绍数组中包含对象的时候需要做去重处理的方法</p><h3 id="1-1-reduce"><a href="#1-1-reduce" class="headerlink" title="1-1.reduce"></a>1-1.reduce</h3><pre><code>var arr = [    { name: &quot;张三&quot;, num: &quot;1&quot; },    { name: &quot;李四&quot;, num: &quot;11&quot; },    { name: &quot;王五&quot;, num: &quot;12&quot; },    { name: &quot;张三&quot;, num: &quot;13&quot; },    { name: &quot;李四&quot;, num: &quot;1&quot; },    { name: &quot;王五&quot;, num: &quot;12&quot; }  ]  /**   *    * @param {*} arr 需要去重的原数组    * @param {*} name  去重字段   * @return  去重之后的新数组   */ function arrayUnique2(arr, name) {    var hash = {};    return arr.reduce(function (item, next) {      hash[next[name]] ? &#39;&#39; : hash[next[name]] = true &amp;&amp; item.push(next);      return item;    }, []);  } arrayUnique2(arr, &quot;name&quot;);  /** [ { name: &#39;张三&#39;, num: &#39;1&#39; },  { name: &#39;李四&#39;, num: &#39;11&#39; },  { name: &#39;王五&#39;, num: &#39;12&#39; } ]  **/</code></pre><h3 id="1-2-for循环"><a href="#1-2-for循环" class="headerlink" title="1-2 for循环"></a>1-2 for循环</h3><p>借助对象访问属性的方法，判断属性是否存在，如果已存在则进行过滤</p><pre><code>var arr = [    { name: &quot;张三&quot;, num: &quot;1&quot; },    { name: &quot;李四&quot;, num: &quot;11&quot; },    { name: &quot;王五&quot;, num: &quot;12&quot; },    { name: &quot;张三&quot;, num: &quot;13&quot; },    { name: &quot;李四&quot;, num: &quot;1&quot; },    { name: &quot;王五&quot;, num: &quot;12&quot; }  ] function deleteSameItemInArray (targetArr,itemName=&#39;&#39;){    let obj = {},result=[]    targetArr.forEach((item,i)=&gt;{        if(!obj[item[itemName]]){            obj[item[itemName]] = true            result.push(item)        }    })    return result  } let resultArr = deleteSameItemInArray(arr2,&#39;name&#39;)console.log(resultArr);</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>async-await和promise的区别</title>
      <link href="/2019/08/12/async-await%E5%92%8Cpromise%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/08/12/async-await%E5%92%8Cpromise%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>为什么要写这篇文章？在面试的时候被问过这个问题，虽然在工作中这两种都用过，但是确实是没考虑过有什么区别，今天再重学一遍。</p><h2 id="1-promise"><a href="#1-promise" class="headerlink" title="1  promise"></a>1  promise</h2><p>Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间，从语法上来说，Promise是一个对象，从它可以获取异步操作的消息。</p><p>基本语法：</p><pre><code>var p1 = new Promise(test);var p2 = p1.then(function (result) {    console.log(&#39;成功：&#39; + result);});var p3 = p2.catch(function (reason) {    console.log(&#39;失败：&#39; + reason);});//支持链式操作p1.then(function (result) {    console.log(&#39;成功：&#39; + result);}).catch(function (reason) {    console.log(&#39;失败：&#39; + reason);});</code></pre><h2 id="2-promsie有三种状态"><a href="#2-promsie有三种状态" class="headerlink" title="2 promsie有三种状态"></a>2 promsie有三种状态</h2><p>ending、fulfilled、rejected(未决定，履行，拒绝)。同一时间只能存在一种状态，且状态一旦改变就不能在变</p><pre><code>1.初始化，状态：pending2.当调用resolve(成功)，状态：pengding=&gt;fulfilled3.当调用reject(失败)，状态：pending=&gt;rejected</code></pre><h2 id="3promise的优缺点"><a href="#3promise的优缺点" class="headerlink" title="3promise的优缺点"></a>3promise的优缺点</h2><p> 优点：</p><p> 1.Promise 分离了异步数据获取和业务逻辑，有利于代码复用。</p><p> 2.可以采用链式写法</p><p> 3.一旦 Promise 的值确定为fulfilled 或者 rejected 后，不可改变。</p><p> 缺点：</p><p>代码冗余，语义不清。</p><h2 id="4-为什么用promise？"><a href="#4-为什么用promise？" class="headerlink" title="4 为什么用promise？"></a>4 为什么用promise？</h2><p><strong>一</strong>.<strong>解决回调地狱</strong></p><p> 回调地狱：发送多个异步请求时，每个请求之间相互都有关联，会出现第一个请求成功后再做下一个请求的情况。我们这时候往往会用嵌套的方式来解决这种情况，但是这会形成”回调地狱“。如果处理的异步请求越多，那么回调嵌套的就越深。出现的问题：</p><p>1.代码逻辑顺序与执行顺序不一致，不利于阅读与维护。</p><p>2.异步操作顺序变更时，需要大规模的代码重构。</p><p>3.回调函数基本都是匿名函数，bug追踪困难</p><p><strong>2.解决异步</strong></p><p>我们都知道js是单线程执行代码，导致js的很多操作都是异步执行（ajax）的，以下是解决异步的几种方式：</p><p> 1.回调函数(定时器)。</p><p> 2.事件监听。</p><p> 3.发布/订阅。</p><p> 4.Promise对象。(将执行代码和处理结果分开)</p><p> 5.Generator。</p><p>6.ES7的async/await。</p><h2 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5. Promise.all()"></a>5. Promise.all()</h2><p>多个promise同时使用，其中一个错误会怎样</p><pre><code>let p1 = Promise.resolve(123);let p2 = Promise.resolve(&#39;hello&#39;);let p3 = Promise.resolve(&#39;success&#39;);Promise.all([p1,p2,p3]).then(result =&gt; {    console.log(result); //[ 123, &#39;hello&#39;, &#39;success&#39; ]})</code></pre><p>Promise.all（）成功之后就是数组类型，当所有状态都是成功状态才返回数组，只要其中有一个的对象是reject的，就返回reject的状态值。</p><pre><code>const pro = (a) =&gt; {    return new Promise((resove,reject)=&gt;{        if(a==1){           setTimeout(()=&gt;{            resove(&quot;this is my data&quot;)           },2000)        }else{            reject(&quot;error data&quot;)        }    })}const pro2 = () =&gt; {    return new Promise((resove,reject)=&gt;{        reject(&quot;error data&quot;)    })}Promise.all([pro(1),pro2()]).then((res)=&gt;{    console.log(res);}).catch((err)=&gt;{    console.log(&#39;走到了catch里面&#39;);    console.log(err); //error data})</code></pre><p>因为pro2函数会reject一个错误，所以后面的promise.all调用的函数数组中，会走到catch里面</p><h2 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6 Promise.race()"></a>6 Promise.race()</h2><p>和all同样接受多个对象，不同的是，race()接受的对象中，哪个对象返回的快就返回哪个对象，就如race直译的赛跑这样。如果对象其中有reject状态的，必须catch捕捉到，如果返回的够快，就返回这个状态。race最终返回的只有一个值。</p><pre><code>//用sleep来模仿浏览器的AJAX请求function sleep(wait) {    return new Promise((res,rej) =&gt; {        setTimeout(() =&gt; {            res(wait);        },wait);    });}let p1 = sleep(500);let p0 = sleep(2000);Promise.race([p1,p0]).then(result =&gt; {    console.log(result); // 500});let p2 = new Promise((resolve,reject) =&gt; {    setTimeout(()=&gt;{        reject(&#39;error data&#39;);    },1000);});Promise.race([p0,p2]).then(result =&gt; {    console.log(result);}).catch(result =&gt; {    console.log(result); // error data});</code></pre><h2 id="6-async-await-与-promsie区别"><a href="#6-async-await-与-promsie区别" class="headerlink" title="6 async/await 与 promsie区别"></a>6 async/await 与 promsie区别</h2><p>异步编程的最高境界，就是根本不关心它异步，async函数可以说是异步函数的最终解决方案。</p><p>async-await与promise不存在谁替换谁的关系，因为async-await是寄生于promise的</p><p>基本语法：</p><pre><code>const pro = (a) =&gt; {    return new Promise((resove,reject)=&gt;{        if(a==1){           setTimeout(()=&gt;{            resove(&quot;this is my data&quot;)           },2000)        }else{            reject(&quot;error data&quot;)        }    })}async function abc(){    let a = await pro(1)    console.log(a); // this is my data    console.log(&#39;hello world&#39;);}abc()</code></pre><p>async函数返回一个promise对象</p><p>规则</p><p>1.async表示这是一个async函数，await只能用在这个函数里面</p><p>2.await表示在这里等待promise返回结果之后，再继续执行</p><p>3.await后面应该跟着一个promise对象（跟普通函数也行，只是时候会立即执行，这样async-await就显得多余了）</p><p>4.await必须放在async里面执行</p><p>5.await等待的虽然是promise对象，但是不必写.then()，可以直接得到返回结果(例如上面代码执行后，2秒钟之后会打印出a的结果为 this is my data)</p><h2 id="7-async的错误处理"><a href="#7-async的错误处理" class="headerlink" title="7 async的错误处理"></a>7 async的错误处理</h2><p>try-catch捕捉</p><pre><code>let p = new Promise((resolve,reject) =&gt; {    setTimeout(() =&gt; {        reject(&#39;error&#39;);    },1000);});async function demo(params) {    try {        let result = await p;    }catch(e) {        console.log(e);    }}demo();</code></pre><h2 id="8-async-await的优缺点"><a href="#8-async-await的优缺点" class="headerlink" title="8 async-await的优缺点"></a>8 async-await的优缺点</h2><p>优点：</p><p>1.解决回调地狱的问题</p><p>2.语法后面不用再加 <code>then</code> 链式回调函数</p><p>3.try/catch 使 async 语法的异常捕获更加好用。</p><p>缺点：</p><p>大多浏览器原生不支持，需要经过babel编译，编译过的代码会变得臃肿</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如何使用VSCode同步插件</title>
      <link href="/2019/05/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/05/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用插件将目前配置保存到GitHub上，以后只需要从GitHub上获取，就可以一次性安装插件配置信息。适合在电脑重装系统的时候快速恢复配置，也适合家里和公司电脑同步配置 </p></blockquote><h2 id="1-Setting-Sync插件"><a href="#1-Setting-Sync插件" class="headerlink" title="1.Setting Sync插件"></a>1.Setting Sync插件</h2><p>首先在VSCode里面搜索Setting Sync插件，安装好后重新加载激活</p><p><img src="/2019/05/17/如何使用VSCode同步插件/01.png" alt=""></p><h2 id="2-生成令牌GitHub-Token"><a href="#2-生成令牌GitHub-Token" class="headerlink" title="2.生成令牌GitHub Token"></a>2.生成令牌GitHub Token</h2><p>打开编辑器，在打开任意文件，按下快捷键 <code>Shift + Alt + U</code>快捷键备份(上传) ,浏览器会跳转到全球最大的同性交友网站登陆，登录你的github账号，在下面页面中点击 Generate new token 生成令牌</p><p><img src="/2019/05/17/如何使用VSCode同步插件/02.png" alt=""></p><p>点击上面按钮后会来到下面页面，填写备注，勾选gist，然后点击绿色的 Generate token按钮</p><p><img src="/2019/05/17/如何使用VSCode同步插件/03.png" alt=""></p><p>这时候就得到了如下的token</p><p><img src="/2019/05/17/如何使用VSCode同步插件/04.png" alt=""></p><h2 id="3-执行备份"><a href="#3-执行备份" class="headerlink" title="3.执行备份"></a>3.执行备份</h2><p>将上面生成的token输入到vscode的命令行中，<code>ctrl + P</code>可打开命令行，输入完命令之后回车，这时候会执行上传操作，成功之后会有如下提示。上传插件成功之后可以在控制台查看一些信息，如GitHub Token 和 GitHub Gist</p><p><img src="/2019/05/17/如何使用VSCode同步插件/05.png" alt=""></p><h2 id="4-保存token和id"><a href="#4-保存token和id" class="headerlink" title="4.保存token和id"></a>4.保存token和id</h2><p>将上述成功的 GitHub Token 和 GitHub Gist 保存在文本里面，可以上传到网盘什么的。</p><p>可以在控制台查看GitHub Token 和 GitHub Gist。也可以在settings.json中查看GitHub Gist ，在github中查看公告生成的GitHub Token </p><p><img src="/2019/05/17/如何使用VSCode同步插件/06.png" alt=""></p><p><img src="/2019/05/17/如何使用VSCode同步插件/07.png" alt=""></p><h2 id="5-恢复下载"><a href="#5-恢复下载" class="headerlink" title="5.恢复下载"></a>5.恢复下载</h2><p>按快捷键 <code>shift+alt+d</code> 或 <code>ctrl+p</code>  输入 <code>&gt;sync</code>点击Download Settings把 GITHUB GIST 的内容粘贴然后回车，即可下载</p><p><img src="/2019/05/17/如何使用VSCode同步插件/08.png" alt=""></p><p><img src="/2019/05/17/如何使用VSCode同步插件/09.png" alt=""></p><p>正常来说上面右下角会显示下载进度，如果不能下载成功很大概率是因为网络问题，打开小飞机之后再试试。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>微信小程序开发记录-2</title>
      <link href="/2019/04/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95-2/"/>
      <url>/2019/04/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>nginx学习记录--前端配置nginx实现跨域</title>
      <link href="/2019/02/18/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/02/18/nginx%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前端配置nginx实现跨域"><a href="#前端配置nginx实现跨域" class="headerlink" title="前端配置nginx实现跨域"></a>前端配置nginx实现跨域</h2><blockquote><p>前言：以前做过jsonp实现跨域，不过这种需要服务端配合。现在的前端项目，比如vue，react等，在配置项目的脚手架中就带有跨域设置，也可以自己写一个node服务来跨域，今天来简单学习一下用nginx来实现跨域。</p></blockquote><h2 id="1-什么是nginx"><a href="#1-什么是nginx" class="headerlink" title="1.什么是nginx"></a>1.什么是nginx</h2><p>nginx是一个高性能的HTTP和反向代理<a href="https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">服务器</a>，也是一个IMAP/POP3/SMTP代理服务器。 nginx的作用是:反向代理，负载均衡。其特点是占有内存少，并发能力强。 </p><h2 id="2-nginx安装"><a href="#2-nginx安装" class="headerlink" title="2.nginx安装"></a>2.nginx安装</h2><h3 id="2-1-windows版："><a href="#2-1-windows版：" class="headerlink" title="2-1 windows版："></a>2-1 windows版：</h3><blockquote><p>nginx下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a> </p></blockquote><p>nginx官网提供了三个类型的版本：</p><ul><li>Mainline version：Mainline 是 Nginx 目前主力在做的版本，可以说是开发版 .</li><li>Stable version：最新稳定版，生产环境上建议使用的版本 </li><li>Legacy versions：遗留的老版本的稳定版 </li></ul><p>​      建议使用稳定版。下载之后解压，解压路径中尽量不要有中文，实际上各种环境配置，软件安装等目录尽量都不要用中文，因为中英文字符编码不一样。</p><p>解压之后的目录就是这样</p><p><img src="/2019/02/18/nginx学习记录/nginx_01.png" alt="nginx_01"></p><p>windows中常用的操做命令，一下命令全在上面根目录进行，用系统自带命令行，比如cmd。</p><p>1.启动nginx。实际上点击nginx.exe也能打开nginx，但是不容易关闭，需要到任务管理器中找到相关服务强行停止掉，建议使用下面命令行开启服务。</p><pre><code>start nginx</code></pre><p>nginx默认使用80端口，如果电脑中有其他服务占用了80端口，修改nginx使用的端口即可。</p><pre><code>server { listen  80;  // 这里改成其他的，比如8082 server_name localhost;}</code></pre><p>2.重启nginx，修改nginx配置之后就需要重启一下</p><pre><code>nginx -s reload</code></pre><p>3.停止nginx。建议使用后面那种停止方式</p><pre><code> nginx -s stop nginx -s quit</code></pre><p>nginx停止命令stop与quit参数的区别在于stop是快速停止nginx，可能并不保存相关信息，quit是完整有序的停止nginx，并保存相关信息。nginx启动与停止命令的效果都可以通过Windows任务管理器中的进程选项卡观察。</p><p>4.其他nginx命令（一般很少用到）</p><pre><code>-?,-h           : 打开帮助信息-v              : 显示版本信息并退出-V              : 显示版本和配置选项信息，然后退出-t              : 检测配置文件是否有语法错误，然后退出-q              : 在检测配置文件期间屏蔽非错误信息-s signal       : 给一个 nginx 主进程发送信号：stop（停止）, quit（退出）, reopen（重启）, reload（重新加载配置文件）-p prefix       : 设置前缀路径（默认是：/usr/local/Cellar/nginx/1.2.6/）-c filename     : 设置配置文件（默认是：/usr/local/etc/nginx/nginx.conf）-g directives   : 设置配置文件外的全局指令</code></pre><h3 id="2-2-mac版"><a href="#2-2-mac版" class="headerlink" title="2-2 mac版"></a>2-2 mac版</h3><p>1.打开终端，安装Command Line tools ，基本上应该都安装过这个，可以跳过</p><pre><code>xcode-select --install</code></pre><p>2.安装brew命令 </p><pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>3.安装nginx </p><pre><code>brew install nginx</code></pre><p>4.启动nginx</p><pre><code>sudo nginx</code></pre><p>5.mac版nginx命令，基本上和windows差不多</p><pre><code>sudo nginx   // 启动sudo -s reload  // 重启sudo -s quit  // 停止sudo -s stop   // 停止</code></pre><p>6.nginx安装目录</p><pre><code>open /usr/local/etc/nginx/</code></pre><h2 id="3-nginx配置"><a href="#3-nginx配置" class="headerlink" title="3.nginx配置"></a>3.nginx配置</h2><p>nginx启动之后，访问<code>http://localhost:8082/</code>，因为我修改了nginx的默认端口为<code>8082</code>。</p><p><img src="/2019/02/18/nginx学习记录/nginx_02.png" alt="02"></p><h3 id="3-1-配置详解"><a href="#3-1-配置详解" class="headerlink" title="3-1 配置详解"></a>3-1 配置详解</h3><p>我们先看一下nginx的默认配置，在conf文件夹中，找到nginx.conf文件。在我这路径为<code>E:\nginx-1.14.2\conf\nginx.conf</code></p><pre><code>#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }        # proxy the PHP scripts to Apache listening on 127.0.0.1:80        #        #location ~ \.php$ {        #    proxy_pass   http://127.0.0.1;        #}        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ {        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><p>上面文件，简单点说就是</p><pre><code>main      events   {        ....      }      http        {        ....        upstream myproject {          .....        }        server  {          ....          location {              ....          }        }        server  {          ....          location {              ....          }      }      ....</code></pre><p>1.main(全局设置) 。主要控制nginx子进程的所属用户/用户组、派生子进程数、错误日志位置/级别、pid位置、子进程优先级、进程对应cpu、进程能够打开的文件描述符数目等。 </p><p>2.events(nginx工作模式) 。控制nginx处理连接的方式 </p><p>3.http(http设置) 。是nginx处理http请求的主要配置模块，大多数配置都在这里面进行。 </p><p>4.sever(主机设置) 。是nginx中主机的配置块，可以配置多个虚拟主机。</p><p>5.location(URL匹配) 。是server中对应的目录级别的控制块，可以有多个。 </p><p>6.upstream(负载均衡服务器设置) 。是nginx做反向代理和负载均衡的配置块，可以有多个。 </p><h3 id="3-1实战练习"><a href="#3-1实战练习" class="headerlink" title="3-1实战练习"></a>3-1实战练习</h3><p>下面我们用豆瓣api V2开放接口来做实验。</p><blockquote><p>接口地址：<a href="http://api.douban.com/v2/movie/top250?start=25&amp;count=25" target="_blank" rel="noopener">http://api.douban.com/v2/movie/top250?start=25&amp;count=25</a> </p></blockquote><p>axios请求：</p><pre><code>axios.get({    method:&#39;get&#39;,    url:&quot;/v2/movie/top250?start=25&amp;count=25&quot;}).then((res)=&gt;{    console.log(res.data)})</code></pre><p>或者使用jquery</p><pre><code>$.get(&quot;/v2/movie/top250?start=25&amp;count=25&quot;, function(data){    console.log(data);})</code></pre><p>要实现跨域，只需要简单修改几个设置。</p><p>1.修改默认配置，大概在35行，80端口改为8082，当然，其他数字也可以，只要是未被占用的端口</p><pre><code> listen       80;</code></pre><p>2.反向代理到webpack-server服务<br>默认代理服务为</p><pre><code> location / {            root   html;            add_header Cache-Control no-store;            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;            index  index.html index.htm;        }</code></pre><p>修改为下面这样，建议注释掉上面部分，新增下面这部分内容。</p><pre><code>     location / {             # 反向代理到webpack-server服务             proxy_pass http://127.0.0.1:8081;        }</code></pre><p>这个匹配规则是，匹配到路由中有<code>/</code>的部分就代理到<code>http://127.0.0.1:8081</code>，相当于全局匹配。。</p><p>然后我们在nginx配置文件中，新增一条配置</p><pre><code>  server {      location ^~ /v2/movie {                proxy_pass http://api.douban.com;            }        }</code></pre><p>这里个规则是匹配到 <code>/v2/movie</code>路由之后，重定向到<code>http://api.douban.com</code></p><p>这里需要注意一点，proxy_pass这里，<code>http://api.douban.com</code>和<code>http://api.douban.com/</code>是不一样的。</p><ul><li>不加<code>/</code>的情况，访问<code>http://10.1.70.229:8082/v2/movie/v2/movie/top250?start=25&amp;count=25</code>会得到<code>http://api.douban.com/v2/movie/top250?start=25&amp;count=25</code>（符合预期的）</li><li>加/的情况,访问<code>http://10.1.70.229:8082/v2/movie/v2/movie/top250?start=25&amp;count=25</code>会得到<code>http://api.douban.com/top250?start=25&amp;count=25</code>（不符合预期）</li></ul><p>下面两种配置效果是一样的。</p><pre><code>location ^~ /v2/movie {                proxy_pass http://api.douban.com;            }</code></pre><p>或</p><pre><code>   location ^~ /v2/movie {            proxy_pass http://api.douban.com/v2/movie/;        }</code></pre><p>针对这种情况，如果后端接口统一有了规定前缀，比如<strong>/api</strong>，那你这里就不要配置斜杠了。另一种情况，后端接口shit一样，没有统一前缀，这边又要区分，那就在前端所有接口都加一个统一前缀，比如<strong>/api</strong>，然后通过加<strong>斜杠</strong>来替换掉好了～ </p><p>删掉多余注释代码，整个nginx.conf文件配置如下。</p><pre><code>worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server {        listen       8082;        server_name  gwg.localhost;        location / {             # 反向代理到webpack-server服务             proxy_pass http://127.0.0.1:8081;        }        # 匹配豆瓣api        location ^~ /v2/movie {            # rewrite ^/v2/movie/(.*)$ /$1 break;            proxy_pass http://api.douban.com;        }        # 匹配到错误之后的处理页        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}</code></pre><h3 id="3-3-rewrite"><a href="#3-3-rewrite" class="headerlink" title="3-3 rewrite"></a>3-3 rewrite</h3><p>rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <code>http://seanlook.com/a/we/index.php?id=1&amp;u=str</code> 只对/a/we/index.php重写。语法<code>rewrite regex replacement [flag];</code></p><p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。</p><p>表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是：</p><ol><li>执行server块的rewrite指令</li><li>执行location匹配</li><li>执行选定的location中的rewrite指令</li></ol><p>如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。</p><p>还是使用豆瓣的接口</p><blockquote><p>接口地址：<a href="http://api.douban.com/v2/movie/top250?start=25&amp;count=25" target="_blank" rel="noopener">http://api.douban.com/v2/movie/top250?start=25&amp;count=25</a> </p></blockquote><p>在js中这样访问，注意多了 /api 部分</p><pre><code>$.get(&quot;/api/v2/movie/top250?start=25&amp;count=25&quot;, function(data){    console.log(data);})</code></pre><p>配置中的location修改为</p><pre><code> location ^~ /api/ {            rewrite ^/api/(.*)$ /$1 break;            proxy_pass http://api.douban.com/;        }</code></pre><p>这里解释为：匹配到请求路径中包含 <code>/api/</code>部分时候，将<code>/api/</code>这部分替换为<code>http://api.douban.com/</code></p><p>也就是说请求的是<code>http://10.1.70.229:8082/api/v2/movie/top250?start=25&amp;count=25</code>，实际上已经代理到<code>http://api.douban.com/api/v2/movie/top250?start=25&amp;count=25</code>，得到了接口的数据</p><h3 id="3-4-location"><a href="#3-4-location" class="headerlink" title="3-4 location"></a>3-4 location</h3><blockquote><p>自出引用自  <a href="https://segmentfault.com/a/1190000002797606#articleHeader0" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002797606#articleHeader0</a></p></blockquote><p>语法规则： location [=|~|~*|^~] /uri/ { … }</p><p>= 开头表示精确匹配</p><p>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。</p><p>~ 开头表示区分大小写的正则匹配</p><p>~*  开头表示不区分大小写的正则匹配</p><p>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则</p><p>/ 通用匹配，任何请求都会匹配到。</p><p>多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：</p><p>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p><pre><code>location = / {     #规则A  }  location = /login {     #规则B  }  location ^~ /static/ {     #规则C  }  location ~ \.(gif|jpg|png|js|css)$ {     #规则D  }  location ~* \.png$ {     #规则E  }  location !~ \.xhtml$ {     #规则F  }  location !~* \.xhtml$ {     #规则G  }  location / {     #规则H  } </code></pre><p>那么产生的效果如下：</p><p>访问根目录/， 比如<a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 将匹配规则A</p><p>访问 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a> 将匹配规则B，<a href="http://localhost/register" target="_blank" rel="noopener">http://localhost/register</a> 则匹配规则H</p><p>访问 <a href="http://localhost/static/a.html" target="_blank" rel="noopener">http://localhost/static/a.html</a> 将匹配规则C</p><p>访问 <a href="http://localhost/a.gif" target="_blank" rel="noopener">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg" target="_blank" rel="noopener">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a href="http://localhost/static/c.png" target="_blank" rel="noopener">http://localhost/static/c.png</a> 则优先匹配到 规则C</p><p>访问 <a href="http://localhost/a.PNG" target="_blank" rel="noopener">http://localhost/a.PNG</a> 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</p><p>访问 <a href="http://localhost/a.xhtml" target="_blank" rel="noopener">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a href="http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。" target="_blank" rel="noopener">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a></p><p>访问 <a href="http://localhost/category/id/1111" target="_blank" rel="noopener">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</p><p>暂时就了解到这里了，后续有机会再次学习…….</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>mac中如何美化命令行工具</title>
      <link href="/2019/01/08/mac%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BE%8E%E5%8C%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/01/08/mac%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BE%8E%E5%8C%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>​    最近在使用Mac的过程中，发现系统自带的命令行工具不是很好看，而自带的一些主题也不够令我喜欢。于是开启了折腾之路</p><blockquote><p>在用户主目录下建立一个配置文件（有文件会进入文件，没有会自动创建）</p></blockquote><pre><code>vi ~/.bash_profile</code></pre><blockquote><p>添加如下代码</p></blockquote><pre><code>#enables colorin the terminal bash shell exportexport CLICOLOR=1#setsup thecolor scheme for list exportexport LSCOLORS=gxfxcxdxbxegedabagacad#sets up theprompt color (currently a green similar to linux terminal)#export PS1=&#39;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]\$&#39;#enables colorfor iTermexport TERM=xterm-256color[ -r ~/.bashrc ] &amp;&amp; source ~/.bashrc</code></pre><blockquote><p>然后再创建一个配置文件（有文件会进入文件，没有会自动创建）</p></blockquote><pre><code>vi ~/.bashrc</code></pre><blockquote><p>添加如下代码</p></blockquote><pre><code>function git_branch {  branch=&quot;`git branch 2&gt;/dev/null | grep &quot;^\*&quot; | sed -e &quot;s/^\*\ //&quot;`&quot;  if [ &quot;${branch}&quot; != &quot;&quot; ];then      if [ &quot;${branch}&quot; = &quot;(no branch)&quot; ];then          branch=&quot;(`git rev-parse --short HEAD`...)&quot;      fi      echo &quot; ($branch)&quot;  fi}export PS1=&#39;\[\033[01;33m\]\u@\h \[\033[01;36m\]\W\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#39;</code></pre><p>其中git_branch这个方法就是为了能够使命令行中显示git分支，PS1是这是命令行的字体颜色配置；</p><p>最终的效果就是这样（在这里用户名，git仓库名和分支名都是用的不同的颜色配置，为了方便区分，修改，删除和新增的文件也有不同的颜色）</p><p><img src="/2019/01/08/mac中如何美化命令行工具/img02.png" alt=""></p><h2 id="1-补充"><a href="#1-补充" class="headerlink" title="1.补充"></a>1.补充</h2><p>上述创建的文件可以在访达中打开查看。因为是隐藏文件，所以需要开启显示隐藏文件的设置才能查看，快捷键 <code>shift+command+.</code></p><h2 id="2-PS1变量详解"><a href="#2-PS1变量详解" class="headerlink" title="2.PS1变量详解"></a>2.PS1变量详解</h2><pre><code>\d ：代表日期，格式为weekday month date\H ：完整的主机名\h ：主机的第一个名字\t ：显示时间为24小时格式(HH:MM:SS)\T ：显示时间为12小时格式\A ：显示时间为24小时格式(HH:MM)\u ：当前用户的账户名\v ：BASH的版本信息\w ：完整的工作目录名\W ：利用basename取得工作目录名称，所以只会列出最后一个目录\# ：第几个命令\$ ：提示字符，如果是root时，提示符为：#;普通用户为：$</code></pre><pre><code>//颜色表前景   背景   颜色30     40    黑色31     41    红色32     42    绿色33     43    黄色34     44    蓝色35     45    紫红色36     46    青蓝色37     47    白色//其他0            OFF1            高亮显示4            underline            7            反白显示8            不可见</code></pre><p>以我的设置为例讲解</p><pre><code>export PS1=&#39;\[\033[01;33m\]\u@\h \[\033[01;36m\]\W\[\033[01;32m\]$(git_branch)\[\033[00m\] \$ &#39;</code></pre><p>\033 声明了转义序列的开始，然后是 [ 开始定义颜色。[]前后都需要加转义字符 \</p><p>比如设置用户名的颜色 [\033[01;33m\] ==&gt; 01表示高亮，33表示黄色，m表示打开前色；后面的颜色同理</p><p>。。。未完待续</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>开发中的一些踩坑记录</title>
      <link href="/2019/01/02/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/02/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>最近在开发中频繁遇到各种问题，针对这些问题花了一些时间来处理，于是记录下来，方便以后查阅。</p><h2 id="1-canvas相关"><a href="#1-canvas相关" class="headerlink" title="1.canvas相关"></a>1.canvas相关</h2><h3 id="1-1、canvas中涉及到图片的绘制"><a href="#1-1、canvas中涉及到图片的绘制" class="headerlink" title="1-1、canvas中涉及到图片的绘制"></a>1-1、canvas中涉及到图片的绘制</h3><p>​    现在有一个业务需求是用canvas来实现，canvas画布里面有网络图片有其他元素有动画之类的，在最后的时候我需要将整个区域截图下来上传到服务器，用的包是html2canvas。 但是这里有个奇怪的问题：跨域。。图片链接测试的时候用的是前端图床里面，本身已经支持跨域的，在普通img标签里面加载整个图片，然后用html2canvas绘制成base64格式图是没问题的，但是这种图片用在canvas里面后，想要将整个canvas绘制成图片，还是依然受跨域问题的影响，截图空白 。</p><pre><code>img.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;); //允许图片跨域let canvas = document.createElement(&#39;canvas&#39;),    ctx = canvas.getContext(&#39;2d&#39;);let img = new Image();    img.src = imgurl;    img.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;); // 注意设置图片跨域应该在图片加载之前    img.onload = function () {        ctx.drawImage(img, 0, 0, 200, 200);}</code></pre><h3 id="1-2、部分ios10，及-lt-ios9的设备中，不兼容上述写法。"><a href="#1-2、部分ios10，及-lt-ios9的设备中，不兼容上述写法。" class="headerlink" title="1-2、部分ios10，及&lt;=ios9的设备中，不兼容上述写法。"></a>1-2、部分ios10，及&lt;=ios9的设备中，不兼容上述写法。</h3><p>​    在canvas绘制图片的时候，一般需要先判断图片加载完了，所以会用到img的onload事件，一般的做法是下面这种。上述drawImage方法是处理具体的逻辑，但是这种写法在部分设备中不兼容。于是改成了下面这种</p><p>​    先放入一个空的img标签,id=’newImg’，设置为用户不可见，在获取到这个dom元素之后，先监听onload事件，然后再给src赋值，这样才会兼容</p><pre><code>let $newImg = document.getElementById(&quot;newImg&quot;);$newImg.setAttribute(&#39;crossorigin&#39;, &#39;anonymous&#39;); $newImg.onload = function(){ // 图片加载完之后进行操作  _this.detailCanvas($newImg,sxData.hand);}$newImg.src = sxData.handUrl;</code></pre><h2 id="2、iOS9及以下设备不兼容forEach？"><a href="#2、iOS9及以下设备不兼容forEach？" class="headerlink" title="2、iOS9及以下设备不兼容forEach？"></a>2、iOS9及以下设备不兼容forEach？</h2><p>暂时不清楚这个bug还是什么情况，但确实在ios9的设备中没有执行forEach里面的逻辑</p><p>原来是这样：（AllLine是数组）</p><pre><code>AllLine.forEach((vDom,k) =&gt; {      vDom.style.width = &#39;0%&#39;;      let imgDom = document.getElementById(`icon${k+1}`);      imgDom.src = loading;      imgDom.className = &quot;loadingImg&quot;})</code></pre><p>后面改成这样才正常</p><pre><code> for (let i = 0; i &lt; AllLine.length; i++) {    let vDom = AllLine[i];    vDom.style.width = &#39;0%&#39;;    let imgDom = document.getElementById(`icon${i+1}`);    imgDom.src = loading;    imgDom.className = &quot;loadingImg&quot;}</code></pre><h2 id="3、在新版ios的微信中，点击input输入框问题"><a href="#3、在新版ios的微信中，点击input输入框问题" class="headerlink" title="3、在新版ios的微信中，点击input输入框问题"></a>3、在新版ios的微信中，点击input输入框问题</h2><p>​    在新版ios的微信中，点击input输入框会顶起页面，这是正常的，但是输入完毕之后，原来软键盘区域会有一片空白，这样有点影响体验，后面看到别的小伙伴的解决方案。scrollIntoViewIfNeeded ，摸索了一下使用方法。</p><p>​    首先简单介绍一下scrollIntoViewIfNeeded 。</p><p>​    根据 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FElement%2FscrollIntoView" target="_blank" rel="noopener">MDN</a>的描述，<code>Element.scrollIntoView()</code>方法让当前的元素滚动到浏览器窗口的可视区域内。而<code>Element.scrollIntoViewIfNeeded（）</code>方法也是用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。此方法是标准的Element.scrollIntoView()方法的专有变体。</p><p>​     兼容性方面，<code>IE</code>和<code>FireFox</code>全红，如果<code>PC</code>端想用的话，基本只能内部项目了，略为可惜。但移动端还是绿悠悠的，基本都OK，可以安心使用~</p><p>​    <code>scrollIntoViewIfNeeded</code>是比较懒散的，如果元素在可视区域，那么调用它的时候，页面是不会发生滚动的。其次是<code>scrollIntoViewIfNeeded</code>只有<code>Boolean</code>型参数，也就是说，都是瞬间滚动，没有动画的可能了。</p><p><code>scrollIntoViewIfNeeded</code>可以接受一个<code>Boolean</code>型参数，和<code>scrollIntoView</code>不同，<code>true</code>为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；<code>false</code>时元素可能顶部或底部对齐，视乎元素靠哪边更近。</p><p>​    下面是我的用法，失去焦点的时候让整个输入框部分与底部对其，因为在我这里，底部就是这个输入框了</p><p><img src="/2019/01/02/开发中的一些踩坑记录/1.png" alt=""></p><h2 id="4-定位问题"><a href="#4-定位问题" class="headerlink" title="4.定位问题"></a>4.定位问题</h2><p>1.position:absolute</p><p>绝对定位的兼容性</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>React生命周期</title>
      <link href="/2018/10/07/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/10/07/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>​    一直没有梳理过react中的生命周期，因为平时常用的生命周期就那么几个，今天就系统的了解一下react中用到的生命周期。</p><p>​    下面看一下一个组件的基本构造。</p><pre><code>import React,{ Component } from &#39;react&#39;;class NewDemo extends Component {  constructor(props,context) {      super(props,context)      this.state = {          //定义state      }  }componentWillMount () {}componentDidMount () {}componentWillReceiveProps (nextProps) {}shouldComponentUpdate (nextProps,nextState) {}componentWillUpdate (nextProps,nextState) {}componentDidUpdate (prevProps,prevState) {}render () {    return (        &lt;div&gt;&lt;/div&gt;    )}componentWillUnmount () {}}export default NewDemo;</code></pre><ul><li><p>React 16.3 新增的生命周期方法</p><p>​    1.getDerivedStateFromProps()</p><p>​    2.getSnapshotBeforeUpdate()</p></li></ul><ul><li><p>逐渐废弃的生命周期方法：</p><p>​    1.componentWillMount()</p><p>​    2.componentWillReceiveProps()</p><p>​    3.componentWillUpdate()</p></li></ul><h1 id="1-constructor"><a href="#1-constructor" class="headerlink" title="1.constructor"></a>1.constructor</h1><p>react组件的构造函数在挂载之前被调用。在实现<code>React.Component</code>构造函数时，需要先在添加其他内容前，调用<code>super(props)</code>，用来将父组件传来的<code>props</code>绑定到这个类中，使用<code>this.props</code>将会得到。</p><p>官方建议不要在<code>constructor</code>引入任何具有副作用和订阅功能的代码，这些应当在<code>componentDidMount()</code>中写入。</p><p><code>constructor</code>中应当做些初始化的动作，如：初始化<code>state</code>，将事件处理函数绑定到类实例上，但也不要使用<code>setState()</code>。如果没有必要初始化state或绑定方法，则不需要构造<code>constructor</code>，或者把这个组件换成纯函数写法。</p><p>​    constructor参数接受两个参数props,context 可以获取到父组件传下来的的props,context,如果你想在        constructor<strong>构造函数内部(注意是内部哦，在组件其他地方是可以直接接收的)</strong>使用props或context,则需要传入，并传入super对象。 </p><pre><code> constructor(props,context) {  super(props,context)  console.log(this.props,this.context) // 在内部可以使用props和context}</code></pre><p>1 constructor必须用super()初始化this, 可以绑定事件到this</p><p>2 如果你在constructor中要使用this.props, 就必须给super加参数, super(props)；</p><p>3 无论有没有constructor, render中都可以使用this.props, 默认自带</p><p>4 如果组件没有声明constructor, react会默认添加一个空的constructor </p><p>5 ES6采用的是先创建父类的实例this（故要先调用 super( )方法），完后再用子类的构造函数修改this</p><h1 id="2-componentWillMount-（组件将要挂载）"><a href="#2-componentWillMount-（组件将要挂载）" class="headerlink" title="2.componentWillMount （组件将要挂载）"></a>2.componentWillMount （组件将要挂载）</h1><p>1、组件刚经历constructor,初始完数据 </p><p>2、组件还未进入render，组件还未渲染完成，dom还未渲染 </p><p>componentWillMount 一般用的比较少，更多的是用在服务端渲染，（我还未使用过react服务端渲染哈，所以也写不了很多） </p><p>但是有一点需要注意的，一般ajax请求不要在这个生命周期里面进行，虽然有些情况下并不会出错，但是如果ajax请求过来的数据是空，那么会影响页面的渲染，可能看到的就是空白。 </p><h1 id="3-componentDidMount（组件渲染完成）"><a href="#3-componentDidMount（组件渲染完成）" class="headerlink" title="3.componentDidMount（组件渲染完成）"></a>3.componentDidMount（组件渲染完成）</h1><p>组件完成装载（已经插入 DOM 树）时，触发该方法。组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染 。 </p><p>一般用于下面场景</p><blockquote><p>1.异步请求 ajax<br>2.添加事件绑定（注意在 componentWillUnmount 中取消，以免造成内存泄漏）</p></blockquote><h1 id="4-componentWillReceiveProps-nextProps"><a href="#4-componentWillReceiveProps-nextProps" class="headerlink" title="4.componentWillReceiveProps (nextProps)"></a>4.componentWillReceiveProps (nextProps)</h1><p>componentWillReceiveProps在接受父组件改变后的props需要重新渲染组件时用到的比较多 </p><pre><code>class ExampleComponent extends React.Component {  state = {    isScrollingDown: false,  };  componentWillReceiveProps(nextProps) {    if (this.props.currentRow !== nextProps.currentRow) {      this.setState({        isScrollingDown:nextProps.currentRow      });    }  }}</code></pre><p>这个方法将被弃用，推荐使用 getDerivedStateFromProps 代替。 </p><h1 id="5-shouldComponentUpdate-nextProps-nextState"><a href="#5-shouldComponentUpdate-nextProps-nextState" class="headerlink" title="5.shouldComponentUpdate(nextProps,nextState)"></a>5.shouldComponentUpdate(nextProps,nextState)</h1><p>​    返回一个布尔值。 </p><p>​    唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，（暂时这么理解，其实setState以后有些情况并不会重新渲染，比如<strong>数组引用不变</strong>）在这里return false可以阻止组件的更新<br>     该方法通过返回 true 或者 false 来确定是否需要触发新的渲染。返回 false， 则不会触发后续的 componentWillUpdate()、render() 和 componentDidUpdate()（但是 state 变化还是可能引起子组件重新渲染）。</p><p>所以通常通过这个方法对 props 和 state 做比较，从而避免一些不必要的渲染。</p><h1 id="6-componentWillUpdate-nextProps-nextState"><a href="#6-componentWillUpdate-nextProps-nextState" class="headerlink" title="6.componentWillUpdate (nextProps,nextState)"></a>6.componentWillUpdate (nextProps,nextState)</h1><p>shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState 。这个平时倒是用的不多。</p><h1 id="7-render函数"><a href="#7-render函数" class="headerlink" title="7.render函数"></a>7.render函数</h1><p><strong>用于将模板转为 HTML 语言，并插入指定的 DOM 节点。</strong> </p><p>render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染 </p><pre><code>ReactDOM.render(  &lt;h1&gt;Hello, world!&lt;/h1&gt;,  document.getElementById(&#39;example&#39;));</code></pre><p>上面代码将一个 h1 标题，插入 example 节点，输出一个h1标签的Hello, world!</p><h1 id="8-componentDidUpdate"><a href="#8-componentDidUpdate" class="headerlink" title="8.componentDidUpdate"></a>8.componentDidUpdate</h1><p>在组件完成更新后立即调用。在初始化时不会被调用。 </p><p>组件一次重新渲染的过程，下面5处打印出来的state应该是相同的。 </p><pre><code>componentWillReceiveProps (nextProps,nextState) {    this.setState({        fengfeng:nextProps.fengfeng    },()=&gt;{        console.log(this.state.fengfeng) //1    })}shouldComponentUpdate (nextProps,nextState) {    console.log(nextState.fengfeng)  //2}componentWillUpdate (nextProps,nextState) {    console.log(nextState.fengfeng)  //3}componentDidUpdate (prevProps,prevState) {    console.log(this.state.fengfeng) //5}render () {    console.log(this.state.fengfeng) //4    return (        &lt;div&gt;&lt;/div&gt;    )}</code></pre><h1 id="9-componentWillUnmount"><a href="#9-componentWillUnmount" class="headerlink" title="9.componentWillUnmount"></a>9.componentWillUnmount</h1><p>在组件从 DOM 中移除之前立刻被调用。 </p><p>componentWillUnmount也是会经常用到的一个生命周期 </p><blockquote><p>1.clear你在组建中所有的setTimeout,setInterval </p><p>2.移除所有组建中的监听 removeEventListener </p><p>3.也许你会经常遇到这个warning: </p></blockquote><pre><code>Can only update a mounted or mounting component. This usually means you called setState() on an        unmounted component. This is a no-op. Please check the code for the undefined component.</code></pre><p>实际的原因是因为在组件挂载（mounted）之后进行了异步操作，比如ajax请求或者设置了定时器等，而你在callback中进行了setState操作。当你切换路由时，组件已经被卸载（unmounted）了，此时异步操作中callback还在执行，请求还未完成，setState没有得到值。因此会报warning 。</p><blockquote><p>我一般是这么解决的</p></blockquote><pre><code>   componentWillUnmount() {        //重写组件的setState方法，直接返回空        this.setState = (state, callback) =&gt; {            return;        };    }</code></pre><blockquote><p>其实还有两种解决方法</p><p>1、<strong>在卸载的时候对所有的操作进行清除（例如：abort你的ajax请求或者清除定时器）</strong> </p></blockquote><pre><code>componentDidMount () {    //1.ajax请求    $.ajax(&#39;你的请求&#39;,{})        .then(res =&gt; {            this.setState({                aa:true            })        })        .catch(err =&gt; {})    //2.定时器    timer = setTimeout(() =&gt; {        //dosomething    },1000)}componentWillUnMount  () {    //1.ajax请求    $.ajax.abort()    //2.定时器    clearTimeout(timer)}</code></pre><blockquote><p>2、<strong>设置一个flag，当unmount的时候重置这个flag</strong> </p></blockquote><pre><code>componentDidMount () {    this._isMounted = true;    $.ajax(&#39;你的请求&#39;,{})        .then(res =&gt; {            if(this._isMounted){                this.setState({                    aa:true                })            }        })        .catch(err =&gt; {})}componentWillUnMount () {    this._isMounted = false;}</code></pre><p>不过根据我的实际经验，还是重写组件的setState方法最管用。</p><h1 id="10-React16新增的生命周期"><a href="#10-React16新增的生命周期" class="headerlink" title="10.React16新增的生命周期"></a>10.React16新增的生命周期</h1><h2 id="10-1-getDerivedStateFromProps"><a href="#10-1-getDerivedStateFromProps" class="headerlink" title="10-1.getDerivedStateFromProps"></a>10-1.getDerivedStateFromProps</h2><p><code>getDerivedStateFromProps</code>在组件实例化后，和接受新的<code>props</code>后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。</p><p>如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。</p><p>调用<code>steState()</code>不会触发<code>getDerivedStateFromProps()</code>。</p><h2 id="10-2、getSnapshotBeforeUpdate"><a href="#10-2、getSnapshotBeforeUpdate" class="headerlink" title="10-2、getSnapshotBeforeUpdate"></a>10-2、getSnapshotBeforeUpdate</h2><pre><code> getSnapshotBeforeUpdate(prevProps, prevState) {    // ...  }</code></pre><p>新的<code>getSnapshotBeforeUpdate</code>生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给<code>componentDidUpdate</code>。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）</p><p>与<code>componentDidUpdate</code>一起，这个新的生命周期将覆盖旧版<code>componentWillUpdate</code>的所有用例。</p><h1 id="11-生命周期各函数的调用顺序"><a href="#11-生命周期各函数的调用顺序" class="headerlink" title="11.生命周期各函数的调用顺序"></a>11.生命周期各函数的调用顺序</h1><p><img src="/2018/10/07/React生命周期/react-01.jpg" alt="img"></p><ol><li><code>getDefaultProps()</code>，调用1次</li><li><code>getInitialState()</code>，调用1次</li><li><code>componentWillMount()</code>，调用1次</li><li><code>render()</code>，调用&gt;=1次</li><li><code>componentDidMount()</code>：仅客户端，调用1次</li><li><code>componentWillReceiveProps(object nextProps)</code>，调用&gt;=0次</li><li><code>ShouldComponentUpdate(object nextProps, object nextState)</code>，调用&gt;=0次</li><li><code>componentWillUpdate(object nextProps, object nextState)</code>，调用&gt;=0次</li><li><code>render()</code>，调用&gt;=1次</li><li><code>componentDidUpdate(object prevProps, object prevState)</code>，调用&gt;=0次</li><li><code>componentWillUnmount()</code>，调用1次</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2018/08/29/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/08/29/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是-Hexo？"><a href="#1-什么是-Hexo？" class="headerlink" title="1.什么是 Hexo？"></a>1.什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h2><pre><code># 安装hexonpm install hexo-cli g# 初始化博客文件夹hexo init blog# 切换到该路径cd blog# 安装hexo的扩展插件npm install# 安装其它插件npm install hexo-server --savenpm install hexo-admin --savenpm install hexo-generator-archive --savenpm install hexo-generator-feed --savenpm install hexo-generator-search --savenpm install hexo-generator-tag --savenpm install hexo-deployer-git --savenpm install hexo-generator-sitemap --save</code></pre><h2 id="3-建站过程"><a href="#3-建站过程" class="headerlink" title="3.建站过程"></a>3.建站过程</h2><pre><code>初始化（ &lt;folder&gt;表示文件夹名字）hexo init &lt;folder&gt;cd &lt;folder&gt;安装依赖npm install</code></pre><p>目录结构如下</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。<a href="http://embeddedjs.com/" target="_blank" rel="noopener">EJS</a>, <a href="http://learnboost.github.io/stylus/" target="_blank" rel="noopener">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> renderer 已默认安装，您可以自由移除。</p><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><p>下面以next主题为例介绍这么搭建个人博客</p><h2 id="4-next主题使用教程"><a href="#4-next主题使用教程" class="headerlink" title="4.next主题使用教程"></a>4.next主题使用教程</h2><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 </p><pre><code>在根目录下执行下面命令，将会在themes文件夹下下载next主题git clone https://github.com/iissnan/hexo-theme-next themes/next也可以直接下载主题包前往 NexT 版本 发布页面https://github.com/iissnan/hexo-theme-next/releases，下载主题包放在themes文件夹下面，并将主题文件夹命名为next(任何名字都可以，主要为了和后面一致)</code></pre><p>打开站点配置文件<code>_config.yml</code>中设置<code>theme: next</code></p><h3 id="4-1启动hexo"><a href="#4-1启动hexo" class="headerlink" title="4-1启动hexo"></a>4-1启动hexo</h3><pre><code>1.第一种方式：直接运行hexo s2.保险一点，先清除缓存再启动服务hexo clean &amp;&amp; hexo s</code></pre><p>这时候会提示</p><pre><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></pre><p>打开浏览器访问：<code>localhost:4000</code>即可看到启动页</p><p><img src="/2018/08/29/hexo搭建博客/01.png" alt=""></p><h2 id="5-案例"><a href="#5-案例" class="headerlink" title="5.案例"></a>5.案例</h2><p>下面以material主题为例介绍我的配置过程</p><h3 id="5-1-安装Materia"><a href="#5-1-安装Materia" class="headerlink" title="5.1 安装Materia"></a>5.1 安装Materia</h3><ul><li>方法一：git clone</li></ul><pre><code>cd themesgit clone https://github.com/viosey/hexo-theme-material.git</code></pre><p>在我实测中，这种方法没有成功，应该是我本身的网络问题。这时候我使用了第二种方法</p><ul><li>方法二：使用npm安装</li></ul><pre><code>npm install hexo-material</code></pre><p>安装完毕后，首先在 hexo 目录下的 themes 文件夹中新建一个文件夹 material ，之后在 hexo 目录下的 node_modules 文件夹中找到 hexo-material 文件夹，然后把里面的全部文件复制到 materia 文件夹里。 </p><p><strong>注意！！！</strong> 需要将 materia 主题下的配置文件 _config.template.yml 重命名为 _config.yml。 然后打开<strong>站点配置文件</strong>（根目录的 _config.yml文件），查找 theme 参数并修改为 materia </p><pre><code>theme: material</code></pre><p>这时候运行</p><pre><code>hexo s </code></pre><p>即可进行预览</p><h3 id="5-2配置主题"><a href="#5-2配置主题" class="headerlink" title="5.2配置主题"></a>5.2配置主题</h3><p>在主题文件夹<code>material</code>文件夹中修改配置。贴出部分配置的介绍</p><pre><code>Material 主题配置文件（节选）# Head infohead:    favicon: &quot;/img/favicon.png&quot; #网站的 favicon    high_res_favicon: &quot;/img/favicon.png&quot;  #高清 favicon    apple_touch_icon: &quot;/img/favicon.png&quot; #iOS 主屏按钮图标    keywords: blog web 前端 #网站关键词url:    rss:   #设置生成的 rss 或 atom url    daily_pic: &quot;https://zhouxiaoyu1994.github.io/FCC2017/resume/index.html&quot;  #设置 daily_pic 模块 点击时跳转的 url    logo: &quot;https://github.com/zhouxiaoyu1994&quot;  #设置 logo 点击时跳转的 urlscheme: Paradox #主题外观（默认）uiux:    slogan: &quot;前端作品集&quot;  #显示在 blog_info 模块中的标语，你可以设置单行标语或者多行标语：    theme_color: &quot;#0097A7&quot;  #主题主要颜色。主题的大部分地方使用此颜色。    theme_sub_color: &quot;#00838F&quot; #主题辅助颜色。    hyperlink_color: &quot;#00838F&quot; #超链接颜色。    button_color: &quot;#757575&quot; #按钮颜色，例如 toTop 或 menu_button。    android_chrome_color: &quot;#0097A7&quot; #安卓 Chrome 浏览器的地址栏颜色。    nprogress_color: &quot;#29d&quot; #页面加载时顶部加载进度条的颜色。    nprogress_buffer: &quot;800&quot; #页面加载时顶部加载进度条的缓冲时间。</code></pre><h3 id="5-3添加站点搜索功能"><a href="#5-3添加站点搜索功能" class="headerlink" title="5.3添加站点搜索功能"></a>5.3添加站点搜索功能</h3><p>使用本地搜索需要安装 <a href="https://link.jianshu.com/?t=https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 插件。 这个插件生成Hexo 3.0的搜索数据。此插件用于生成搜索索引文件，其中包含您可以用来为您的博客编写本地搜索引擎的文章的所有必要数据。支持XML和JSON格式输出。 </p><p>然后在 <strong>站点配置文件</strong>中添加 </p><pre><code>search:path: search.xmlfield: all</code></pre><p>然后根目录运行下面命令，将在公共文件夹中获取生成的结果。 </p><pre><code>hexo g</code></pre><h2 id="6-写作与发布"><a href="#6-写作与发布" class="headerlink" title="6.写作与发布"></a>6.写作与发布</h2><h3 id="6-1新建博客"><a href="#6-1新建博客" class="headerlink" title="6-1新建博客"></a>6-1新建博客</h3><pre><code>hexo new &#39;新建博客&#39;</code></pre><p>这时候会在 ./source./_posts 路径里面有个叫‘新建博客’的md文件和文件夹，文件夹是用来放静态资源</p><h3 id="6-2-发布"><a href="#6-2-发布" class="headerlink" title="6-2 发布"></a>6-2 发布</h3><ul><li>1.安装hexo-deployer-git </li></ul><pre><code>npm install hexo-deployer-git --save</code></pre><ul><li>2.在站点配置文件里面配置git仓库地址</li></ul><pre><code>deploy:  type: git   repository: https://github.com/terry-guo/terry-guo.github.io.git  branch: master</code></pre><ul><li>3.部署到github </li></ul><pre><code>hexo d -g发布</code></pre><ul><li>4.访问下<a href="https://terry-guo.github.io/。试试（terry-guo是我的用户名）">https://terry-guo.github.io/。试试（terry-guo是我的用户名）</a> </li></ul><p>目前只是初步形态，后续将会继续优化，完善各方面功能。</p><h2 id="7、拓展功能"><a href="#7、拓展功能" class="headerlink" title="7、拓展功能"></a>7、拓展功能</h2><h3 id="7-1加一个动态背景效果"><a href="#7-1加一个动态背景效果" class="headerlink" title="7-1加一个动态背景效果"></a>7-1加一个动态背景效果</h3><p>在material主题文件的<code>layout</code>文件夹中的index.ejs和post.ejs中引入这样一段代码</p><pre><code> &lt;script&gt;            //背景线条            !function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return{l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)}}function o(){a=m.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,c=m.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){r.clearRect(0,0,a,c);var n,e,t,o,m,l;s.forEach(function(i,x){for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;a||i.x&lt;0?-1:1,i.ya*=i.y&gt;c||i.y&lt;0?-1:1,r.fillRect(i.x-.5,i.y-.5,1,1),e=x+1;e&lt;u.length;e++)n=u[e],null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,m=i.y-n.y,l=o*o+m*m,l&lt;n.max&amp;&amp;(n===y&amp;&amp;l&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*m),t=(n.max-l)/n.max,r.beginPath(),r.lineWidth=t/2,r.strokeStyle=&quot;rgba(&quot;+d.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,r.moveTo(i.x,i.y),r.lineTo(n.x,n.y),r.stroke()))}),x(i)}var a,c,u,m=document.createElement(&quot;canvas&quot;),d=t(),l=&quot;c_n&quot;+d.l,r=m.getContext(&quot;2d&quot;),x=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,1e3/45)},w=Math.random,y={x:null,y:null,max:2e4};m.id=l,m.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+d.z+&quot;;opacity:&quot;+d.o,e(&quot;body&quot;)[0].appendChild(m),o(),window.onresize=o,window.onmousemove=function(n){n=n||window.event,y.x=n.clientX,y.y=n.clientY},window.onmouseout=function(){y.x=null,y.y=null};for(var s=[],f=0;d.n&gt;f;f++){var h=w()*a,g=w()*c,v=2*w()-1,p=2*w()-1;s.push({x:h,y:g,xa:v,ya:p,max:6e3})}u=s.concat([y]),setTimeout(function(){i()},100)}();;            &lt;/script&gt;</code></pre><p>这样页面背景中就多了一个线条跟随鼠标动的动态效果。至于要改变背景颜色图片什么的，就找到对应的标签去写样式覆盖。</p><h3 id="7-2-加入Q版看板娘"><a href="#7-2-加入Q版看板娘" class="headerlink" title="7-2 加入Q版看板娘"></a>7-2 加入Q版看板娘</h3><p>参考这个</p><blockquote><p><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a></p></blockquote><p>安装模块</p><pre><code>npm install --save hexo-helper-live2d</code></pre><p>然后安装具体的模型（我比较喜欢这里面的2个）</p><pre><code>npm install --save live2d-widget-model-shizukunpm install --save live2d-widget-model-miku</code></pre><p>然后在根目录的<code>config.yml</code>文件中加入下面一段</p><pre><code>#萌萌哒的日本动漫图live2d:  model:           #这里设置的use就是你要用的那个模型      use: live2d-widget-model-shizuku      #use: live2d-widget-model-miku  display:    position: right    bottom: -60    width: 120    height: 240  mobile:    show: true</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>对document.referrer的理解</title>
      <link href="/2018/08/17/document-referrer%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
      <url>/2018/08/17/document-referrer%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-document-referrer"><a href="#1-document-referrer" class="headerlink" title="1.document.referrer"></a>1.document.referrer</h3><p>​    最近有个需求需要实现一个功能，需要判断用户是从A页面扫码进来的B页面，还是直接在地址栏中输入B页面的的链接进来。当时第一个想到的就是document.referrer。</p><p>​    javascript 有一个可以获取前一页面的URL地址的方法：<strong>document.referrer</strong></p><p><strong>document.referrer 的来源</strong></p><ol><li>referrer 属性可返回载入当前文档的文档的 URL, 如果当前文档不是通过超链接访问的，那么当前文档的URL为NULL，这个属性允许客户端的 javascript 访问 HTTP 头部；</li><li>referrer 属性，我们可以从 http 头部获取</li></ol><p><strong>document.referrer 的兼容性</strong></p><p>document.referrer IE7都支持，它的兼容性比较高，Android 5.0开始支持，iOS都支持，PC端浏览器从IE7就开始支持了，兼容性没有什么大的问题。</p><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>​    从使用意义上来说document.referrer希望能够追踪到的是浏览器端行为。如果B页面被打开，那么浏览器端可能会发生的动作有用户操作、JS代码两种。 </p><p>先来看看用户打开页面A可能会进行的操作：这里的link即指<a>标签 </a></p><table><thead><tr><th>1</th><th>直接在地址栏中输入A的地址</th></tr></thead><tbody><tr><td>2</td><td>从A页面左击link B，跳转至A页面</td></tr><tr><td>3</td><td>从A页面左击link B，在新窗口中打开</td></tr><tr><td>4</td><td>从A页面左击link B，在新标签页中打开</td></tr><tr><td>5</td><td>拖动link A至地址栏</td></tr><tr><td>6</td><td>拖动link A至标签栏</td></tr><tr><td>7</td><td>使用浏览器的前进、后退按钮</td></tr></tbody></table><p>JS打开页面可能的方式：</p><table><thead><tr><th>1</th><th>修改window.location</th></tr></thead><tbody><tr><td>2</td><td>使用window.open</td></tr></tbody></table><p>上面列出了客户端打开页面的一些方法，此外，如果通过服务端的重定向技术，也能够使得页面A呈现给访客。</p><p>下面来针对具体的浏览器测试，如果是上述的这些情况，document.referrer表现如何：</p><table><thead><tr><th>序号</th><th>场景</th><th>IE8.0</th><th>FF3.6</th><th>FF4.0</th><th>chrome</th></tr></thead><tbody><tr><td>1</td><td>直接在地址栏中输入B的地址</td><td>“ “</td><td>“ “</td><td>“ “</td><td>“ “</td></tr><tr><td>2</td><td>从A页面左击link B，B页面替换A页面(target=’_self’)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>3</td><td>从A页面左击link B，B在新窗口中打开(target=’_blank’)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>3</td><td>从A页面右击link B，在新窗口中打开</td><td>√</td><td>√</td><td>√</td><td>“ “</td></tr><tr><td>4</td><td>从A页面右击link B，在新标签页中打开</td><td>√</td><td>√</td><td>√</td><td>“ “</td></tr><tr><td>5</td><td>鼠标拖动link B至地址栏</td><td>／</td><td>“ “</td><td>“ “</td><td>“ “</td></tr><tr><td>6</td><td>鼠标拖动link B至标签栏</td><td>“ “</td><td>“ “</td><td>“ “</td><td>“ “</td></tr><tr><td>7</td><td>使用浏览器的前进、后退按钮</td><td>保持</td><td>保持</td><td>保持</td><td>保持</td></tr><tr><td>8</td><td>修改window.location打开B页面(同域)</td><td>“ “</td><td>√</td><td>√</td><td>√</td></tr><tr><td>9</td><td>使用window.open打开B页面</td><td>“ “</td><td>√</td><td>√</td><td>√</td></tr><tr><td>10</td><td>服务器重定向至B页面</td><td>“ “</td><td>“ “</td><td>“ “</td><td>“ “</td></tr></tbody></table><p>其中，” “表示一个空的字符串，√表示能够正确判断来源页，保持则意味使用前进后退不会改变页面的referrer。从这张表里可以看出document.referrer能覆盖大约一半的case。但是对于一些比较常用的操作，例如利用鼠标拖动link至标签栏、前进后退等情况还不能做出正确的处理。</p><h3 id="3-无法获取-referrer-信息的情况"><a href="#3-无法获取-referrer-信息的情况" class="headerlink" title="3,无法获取 referrer 信息的情况"></a>3,无法获取 referrer 信息的情况</h3><p>下面的场景无法获得 referrer 信息：</p><ol><li><p>直接在浏览器中输入地址</p></li><li><p>使用<code>location.reload()</code>刷新（<code>location.href</code>或者<code>location.replace()</code>刷新有信息）</p></li><li><p>在微信对话框中，点击进入微信自身浏览器</p></li><li><p>扫码进入微信或QQ的浏览器</p></li><li><p>直接新窗口打开一个页面</p></li><li><p>从https的网站直接进入一个http协议的网站（Chrome下亲测）</p></li><li><p><code>a</code>标签设置<code>rel=&quot;noreferrer&quot;</code>（兼容IE7+）</p></li><li><p><code>meta</code>标签来控制不让浏览器发送<code>referer</code></p><pre><code>&lt;meta content=&quot;never&quot; name=&quot;referrer&quot;&gt;</code></pre></li><li><p>点击 flash 内部链接</p></li><li><p>Chrome4.0以下，IE 5.5+以下返回空的字符串</p></li><li><p>使用 修改 Location 进行页面导航的方法，会导致在IE下丢失 referrer，这可能是IE的一个BUG</p></li><li><p>跨域</p></li></ol><h3 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4.结束语"></a>4.结束语</h3><p>​    因为最终的使用场景中，从A页面扫码进入B页面的过程中，后端小哥哥做了302重定向跳转到B页面，这时候在B页面获取到的<code>document.referrer</code>也是<code>&quot;&quot;</code>。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>offset、client和scroll三大家族对比</title>
      <link href="/2018/08/06/offset%E3%80%81client%E5%92%8Cscroll%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F%E5%AF%B9%E6%AF%94/"/>
      <url>/2018/08/06/offset%E3%80%81client%E5%92%8Cscroll%E4%B8%89%E5%A4%A7%E5%AE%B6%E6%97%8F%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="一、关于网页中位置和距离的各种操作"><a href="#一、关于网页中位置和距离的各种操作" class="headerlink" title="一、关于网页中位置和距离的各种操作"></a>一、关于网页中位置和距离的各种操作</h1><p>​    因为最近做的一个需求需要用到上拉刷新，这时候需要判断某个dom对象的位置，这是又想起了曾经折磨过我的三大家族。</p><p>​    网页可见区域宽： document.body.clientWidth;</p><p>​    网页可见区域高： document.body.clientHeight;</p><p>​    网页可见区域宽： document.body.offsetWidth (包括边线的宽);</p><p>​    网页可见区域高： document.body.offsetHeight (包括边线的宽);</p><p>​    网页正文全文宽： document.body.scrollWidth;</p><p>​    网页正文全文高： document.body.scrollHeight;</p><p>​    网页被卷去的高： document.body.scrollTop;</p><p>​    网页被卷去的左： document.body.scrollLeft;</p><h2 id="1、offSet家族"><a href="#1、offSet家族" class="headerlink" title="1、offSet家族"></a>1、offSet家族</h2><p>offSet 自己的，用于获取元素自己本身的尺寸 。</p><h3 id="1-1、offsetHeight和offsetWidth"><a href="#1-1、offsetHeight和offsetWidth" class="headerlink" title="1-1、offsetHeight和offsetWidth"></a>1-1、offsetHeight和offsetWidth</h3><p>获取对象自身的宽度和高度 ，包括内容、边框和内边距，即：<code>offsetWidth = width + border + padding</code> </p><h3 id="1-2、offsetLeft-和-offsetTop"><a href="#1-2、offsetLeft-和-offsetTop" class="headerlink" title="1-2、offsetLeft 和 offsetTop"></a>1-2、offsetLeft 和 offsetTop</h3><p>距离第一个有定位的父级盒子左边和上边的距离，注意：<strong>父级盒子必须要有定位，如果没有，则最终以body为准！</strong> <img src="/2018/08/06/offset、client和scroll三大家族对比/01.png" alt="01">总结：offsetLeft和offsetTop从从父标签的padding开始计算，不包括border。即：从子盒子边框到定位父盒子边框的距离。 </p><h3 id="1-3、offsetParent"><a href="#1-3、offsetParent" class="headerlink" title="1-3、offsetParent"></a>1-3、offsetParent</h3><p>**返回当前对象的父级（带有定位）盒子，可能是父级元素，也可能是父级元素的父级……</p><ul><li>如果当前元素的父级元素没有进行CSS定位（position：absolute 或 relative），则其offsetParent为<strong>body；</strong> 如果当前元素的父级元素中有CSS定位（position：absolute或relative），offsetParent取<strong>最近的那个父级元素</strong>。</li></ul><h3 id="1-4、offsetXXX-和-style-XXX的区别"><a href="#1-4、offsetXXX-和-style-XXX的区别" class="headerlink" title="1-4、offsetXXX 和 style.XXX的区别"></a>1-4、offsetXXX 和 style.XXX的区别</h3><p>用offsetLeft和style.left来分析，其他的以此类推： </p><pre><code>a) style.left只能获取行内的，而offsetLeft则可以获取到所有的；b) offsetLeft 可以返回没有定位盒子距离左侧的位置；而style.left不可以，其只能返回有定位盒子的left;c) offsetLeft 返回的是数字，而 style.left 返回的是字符串，除了数字外还带有单位：px;   注意：可以用parseInt进行转化；比如：styleLeft=&#39;300px&#39; ---&gt; parseInt(styleLft) ---&gt; 300d) offsetLeft是只读的，而style.left是可读写；e) 如果没有给 当前 元素指定过 top 样式，则 style.top 返回的是空字符串。</code></pre><h2 id="2、scroll家族"><a href="#2、scroll家族" class="headerlink" title="2、scroll家族"></a>2、scroll家族</h2><ul><li>网页正文全文宽： document.body.scrollWidth;</li><li>网页正文全文高： document.body.scrollHeight;</li><li>网页被卷去的高： document.body.scrollTop;</li><li>网页被卷去的左： document.body.scrollLeft;</li></ul><p>在实际开发中使用比较多的就是<strong>scrollTop，</strong>如下图： <img src="/2018/08/06/offset、client和scroll三大家族对比/02.png" alt="02"></p><h3 id="2-1、处理scroll家族浏览器适配问题"><a href="#2-1、处理scroll家族浏览器适配问题" class="headerlink" title="2-1、处理scroll家族浏览器适配问题"></a>2-1、处理scroll家族浏览器适配问题</h3><ul><li><strong>ie9+ 和 最新浏览器</strong></li></ul><pre><code>    window.pageXOffset; （scrollLeft）    window.pageYOffset; （scrollTop）</code></pre><ul><li><p><strong>Firefox浏览器 和 其他浏览器</strong></p><pre><code>document.documentElement.scrollTop;</code></pre></li><li><p><strong>Chrome浏览器 和 没有声明 DTD <doctype></doctype></strong></p><pre><code>document.body.scrollTop;</code></pre></li><li><p><strong>兼容写法</strong></p><pre><code> var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;  var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;</code></pre></li></ul><h3 id="2-1、scrollTo-x-y"><a href="#2-1、scrollTo-x-y" class="headerlink" title="2-1、scrollTo(x,y)"></a>2-1、scrollTo(x,y)</h3><ul><li>把内容滚动到指定的坐标</li><li>格式：scrollTo(xpos,ypos)<ul><li>xpos 必需；要在窗口文档显示区左上角显示的文档的 x 坐标；</li><li>ypos 必需；要在窗口文档显示区左上角显示的文档的 y 坐标 。</li></ul></li><li>网页大部分都没有水平滚动条，所以，这个x 不太常用。</li></ul><h2 id="3、client家族"><a href="#3、client家族" class="headerlink" title="3、client家族"></a>3、client家族</h2><h3 id="3-1、-clientWidth和clientHeight"><a href="#3-1、-clientWidth和clientHeight" class="headerlink" title="3-1、 clientWidth和clientHeight"></a>3-1、 clientWidth和clientHeight</h3><ul><li>网页可见区域宽： document.body.clientWidth;</li><li>网页可见区域高： document.body.clientHeight;</li></ul><h3 id="3-2、-clientLeft和clientTop"><a href="#3-2、-clientLeft和clientTop" class="headerlink" title="3.2、 clientLeft和clientTop"></a>3.2、 clientLeft和clientTop</h3><ul><li><p><strong>clientLeft，clientTop</strong></p><ul><li>返回的是元素边框的borderWidth，</li><li>如果不指定一个边框或者不定位改元素，其值就为0</li></ul><p>·           Client家族和offset家族一样只能获取不能设置</p><p>·          clientWidth=width+padding</p><p>·          clientHeight=height+padding</p><p>·          </p><p>·         不常用：</p><p>·         clientTop=获取左边框的宽度</p><p>·         clientLeft=获取上边框的宽度</p></li></ul><h2 id="二、-offset、client和scroll的区别分析"><a href="#二、-offset、client和scroll的区别分析" class="headerlink" title="二、 offset、client和scroll的区别分析"></a>二、 offset、client和scroll的区别分析</h2><ul><li><p><strong>left和top分析：</strong></p><ul><li><p>clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度</p><p>clientWidth=width+padding</p><p>clirntHeight= height+padding</p></li></ul></li><li><p>offsetLeft: 当前元素距离有定位的父盒子左边的距离；offsetTop: 当前元素距离有定位的父盒子上边的距离</p><p>offectWidth= width+padding+border</p><p>offextHeight= height+padding+border</p></li><li><p>scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度;</p><p>scrollWidth=内容的宽度</p><p>scrollHeight=内容的高度</p></li><li><p><strong>width和height分析</strong></p><ul><li>clientWidth / Height: 内容 + 内边距</li><li>offsetWidth / Height: 内容 + 内边距 + 边框</li><li>scrollWidth / Height: 滚动内容的宽度和高度</li><li><img src="/2018/08/06/offset、client和scroll三大家族对比/03.png" alt="03"></li></ul></li></ul><h2 id="三、获取屏幕的可视区域"><a href="#三、获取屏幕的可视区域" class="headerlink" title="三、获取屏幕的可视区域"></a>三、获取屏幕的可视区域</h2><ul><li><p>ie9及其以上的版本、最新浏览器</p><pre><code>window.innerWidth, window.innerHeight</code></pre></li><li><p>标准模式浏览器</p><pre><code>document.documentElement.clientWidth, document.documentElement.clientHeight</code></pre></li><li><p>怪异模式</p><pre><code>document.body.clientWidth, document.body.clientHeight</code></pre></li><li><p>通用写法</p><pre><code>function client() {       if(window.innerWidth){ // ie9及其以上的版本           return{               width: window.innerWidth,               height:  window.innerHeight           }       }else if(document.compatMode != &#39;CSS1Compat&#39;){  // 怪异模式           return{               width: document.body.clientWidth,               height: document.body.clientHeight           }       }       // 标准       return{             width: document.documentElement.clientWidth,             height: document.documentElement.clientHeight       }}</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ReactNative入门</title>
      <link href="/2018/08/06/react-native/"/>
      <url>/2018/08/06/react-native/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ReactNative基础"><a href="#1-ReactNative基础" class="headerlink" title="1.ReactNative基础"></a>1.ReactNative基础</h1><h2 id="1-RN的介绍"><a href="#1-RN的介绍" class="headerlink" title="1.RN的介绍"></a>1.RN的介绍</h2><p><strong><img src="/2018/08/06/react-native/1.png" alt="img"></strong></p><p>尽管在移动开发中，原生App的开发成本很高，但现阶段基于原生开发仍然是必须的，因为Web的用户体验仍无法超越Native，主要体现在：</p><ul><li>Native的原生控件有更好的体验；</li><li>Native有更好的手势识别；</li><li>Native有更合适的线程模型，尽管Web Worker可以解决一部分问题，但如图像解码、文本渲染仍无法多线程渲染，这影响了Web的流畅性。</li></ul><blockquote><p><strong>思考？</strong></p><p>怎么做才能拥有Native的体验和性能，又能够高效率开发、跨平台开发？</p></blockquote><p><strong>一、答案</strong></p><pre><code>  React Native于F8大会开源,在短短不到一年的时间里,它成为手机端必不可少的开发模式之一。 它充分利用了Facebook现有的业务轮子, 其核心设计理念：**既拥有Native的用户体验、又保留React的开发效率**。`(  React : 1.有一个虚拟dom ; 2.基于组件 ; 3.状态机  )`  目前，React Native基本完成了对多端的支持，实现了真正意义上的面向配置开发: 开发者可以灵活的使用HTML和CSS布局,使用React语法构建组件,实现：**Android, iOS 两端代码的复用**。</code></pre><p><strong><img src="/2018/08/06/react-native/2.png" alt="img"></strong></p><pre><code>   此外，使用流畅度和原生的保持在同一层次,这不是我们梦寐以求的开发模式吗?让我们从无到有开启新的学习篇章吧!</code></pre><p><strong>二、什么是React Native？</strong></p><p><strong>（一）时下移动互联网主流技术</strong></p><pre><code>       BAT等一线互联网公司的插件化，热修改等技术       阿里的Weex、尤雨溪的Vue.js等       React 与 React Native技术</code></pre><p><strong>（二）React Native介绍</strong></p><pre><code>      Facebook于2015年9月15日发布**React Native;**      广大开发者可以使用JavaScript和React开发跨平台移动应用;      React Native特点：      1）使用 **Virtual DOM**；</code></pre><p>​        1)通过JS对象模拟原生DOM，加上DOM Diff 极大提升了<strong>DOM操作的性能</strong></p><pre><code>     2)浏览器中，Virtual DOM最终编译成了DOM ; 但是在 iOS中，Virtual DOM却完全可以编译成                              </code></pre><p>​          oc的组件，甚至在安卓、windows、mac osx 中都完全<strong>可以编译成对应的UI组件</strong></p><pre><code>      2）提供了**响应式**（Reactive）和**组件化**（Composable）的视图组件；</code></pre><p>​        例如：响应式开发的页面会根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行    </p><p>​                           相应的响应和调整 ,  响应式的页面有能力去自动响应用户的设备环境。</p><p>​        例如：每一个组件都有自己清晰的职责，完整的功能，较低的耦合便于单元测试和重复利用；</p><p>​               低耦合性，通俗点说，代码独立不会和项目中的其他代码发生冲突等。</p><pre><code>      3）将注意力集中保持在核心库，伴随于此，有配套的**路由**和负责处理**全局状态管理**的库。</code></pre><p> （<strong>三）React Native的优势</strong></p><pre><code>  1）跨平台开发    运用React Native，我们可以使用同一份业务逻辑核心代码来创建原生应用运行在Web端，Android端和iOS端； 2）追求极致的用户体验：实时热部署  </code></pre><p>   3）learn once ,  write everywhere （最具魅力）</p><pre><code>    React Native不强求一份原生代码支持多个平台，所以不是“Write once, run anywhere”（Java），而是“Learn once, write anywhere”。    ![img](/react-native/3.png)</code></pre><p><strong>（四）React Native开发注意事项</strong></p><pre><code>  1）目前react native在iOS上仅支持**ios7**以上，Android仅支持**Android4.1**以上版本；   github地址:  https://github.com/facebook/react-native    官网文档: http://facebook.github.io/react-native/docs/getting-started.html  2 )由于React Native的版本更新速度很快( bug ,不稳定 )，如果没有深厚的JavaScript基础，建议：      **a、功能适中，交互一般，不需要特别多的系统原生支持；**</code></pre><p>​      <strong>b、对于部分复杂的应用，可以考虑原生+React Native混合开发</strong></p><h2 id="2-ReactNative开发环境搭建"><a href="#2-ReactNative开发环境搭建" class="headerlink" title="*2.ReactNative开发环境搭建"></a>*2.ReactNative开发环境搭建</h2><p>ReactNative 开发环境搭建：<a href="http://reactnative.cn/docs/0.48/getting-started.html" target="_blank" rel="noopener">http://reactnative.cn/docs/0.48/getting-started.html</a></p><p>ReactNative 视频教程：<a href="https://ke.qq.com/course/197101" target="_blank" rel="noopener">https://ke.qq.com/course/197101</a></p><h3 id="1-安装jdk1-8"><a href="#1-安装jdk1-8" class="headerlink" title="1.安装jdk1.8"></a>1.<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">安装jdk1.8</a></h3><p>参考：<a href="https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html</a></p><h3 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2.*安装android studio"></a>2.<a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">*安装android studio</a></h3><p>打开Android SDK Manager。</p><p>选中以下项目，以下的是必需安装：</p><ul><li>Android SDK Build-tools version 23.0.1</li><li>Android Support Repository</li><li>Android 6.0 (API 23)</li></ul><h3 id="3-配置sdk路径"><a href="#3-配置sdk路径" class="headerlink" title="3.配置sdk路径"></a>3.<a href="">配置sdk路径</a></h3><ul><li>添加环境变量ANDROID_HOME ：android sdk根路径</li><li>修改path路径:%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools</li></ul><p><strong>以上1-3步骤是搭建android开发环境</strong>, 因为ReactNative的开发环境是依赖Android开发环境</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-安装Python2"><a href="#4-安装Python2" class="headerlink" title="4.安装Python2"></a>4.<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">安装Python2</a></h3><p>将python加入环境变量，然后可以通过 <code>python</code> 的命令来测试python是否安装成功</p><p>参考：<a href="https://jingyan.baidu.com/article/c910274be14d64cd361d2dd8.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c910274be14d64cd361d2dd8.html</a></p><h3 id="5-安装node"><a href="#5-安装node" class="headerlink" title="5.安装node"></a>5.<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装node</a></h3><pre><code>ReactNative是基于js的，Node.js轻量级的Web服务器，想要是React Native跑起来需要安装node， 如果没有安装node.js，先去官网安装node.js,最好是4.1以上版本可以通过node -v的命令来测试NodeJS是否安装成功//安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global</code></pre><h3 id="6-安装git-可选"><a href="#6-安装git-可选" class="headerlink" title="6.安装git(可选)"></a>6.<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">安装git(可选)</a></h3><pre><code>安装React-native可能需要用到Git，如果没有配置git，需要先下载对应的客户端，然后将git加入path环境变量</code></pre><h3 id="7-安装yarn-和-react-native命令行工具react-native-cli"><a href="#7-安装yarn-和-react-native命令行工具react-native-cli" class="headerlink" title="7.安装yarn 和 react-native命令行工具react-native-cli"></a>7.安装yarn 和 react-native命令行工具<a href="">react-native-cli</a></h3><p>第一种(推荐)：</p><pre><code>npm install -g yarn react-native-cli//安装完yarn后同理也要设置镜像源：yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global</code></pre><blockquote><p>注意 : </p><p>1.如果yarn安装成功, 但是yarn 命令使用不了,这时应该配置yarn 工具的环境变量.  yran工具默认的安装路径是: C:\dev\nvm\npm\node_modules\yarn\bin</p><p>2.如果react-native-cli 安装成功, 但是react-native-cli 命令使用不了,这时应该配置react-native-cli 工具的环境变量.  react-native-cli 工具默认的安装路径是:C:\dev\nvm\npm</p></blockquote><p>参考：<a href="http://blog.csdn.net/u012987546/article/details/52210530" target="_blank" rel="noopener">http://blog.csdn.net/u012987546/article/details/52210530</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>flex弹行布局</title>
      <link href="/2018/08/06/flex/"/>
      <url>/2018/08/06/flex/</url>
      
        <content type="html"><![CDATA[<h1 id="一、弹性布局介绍"><a href="#一、弹性布局介绍" class="headerlink" title="一、弹性布局介绍"></a>一、弹性布局介绍</h1><p>​    在以往做过的几个项目中，我曾多次使用flex布局，对于这个css3的新属性简直是爱的不行，今天给大家简单的介绍一下flex布局。本人阅历见识以及知识储备尚浅，其中若有错误和不足之处还望各位大佬能指出。</p><p>​    网页布局（layout）是 CSS 的一个重点应用。在传统布局基于盒状模型，依赖 <code>display</code>属性 +<code>position</code>属性+<code>float</code>属性。这些对于那些特殊的布局非常不方便，比如垂直居中。</p><p>​    2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。</p><p><img src="/2018/08/06/flex/001.png" alt=""></p><p>从上图可以看出，前主流的浏览器都支持flex布局，</p><h1 id="二、基础篇"><a href="#二、基础篇" class="headerlink" title="二、基础篇"></a>二、基础篇</h1><h2 id="01、什么是Flex布局？"><a href="#01、什么是Flex布局？" class="headerlink" title="01、什么是Flex布局？"></a>01、什么是Flex布局？</h2><p>​    Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。旨在通过弹性的方式来对齐和分布容器中内容的空间，使其能适应不同屏幕，为盒装模型提供最大的灵活性任。何一个容器都可以指定为 Flex 布局。</p><p>​      FlexBox布局<strong>更多的用到</strong>移动端<strong>，PC端除了</strong>盒子模型<strong>布局，也支持</strong>FlexBox<strong>布局 , FlexBox布局将会是成为</strong>未来开发的主流技术，将在移动端体现的最明显。</p><p>​    采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>​    html部分：</p><pre><code>&lt;div class=&quot;box&quot;&gt;       &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/div&gt;</code></pre><p>​    css部分：</p><pre><code> .box{     display: flex;   }</code></pre><p>上面就是一个最简单的flex布局，任何元素都能设置flex布局。行内元素写作<code>display:inline-flex</code>。</p><p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和 <code>vertical-align</code>属性将失效。</p><ul><li>​</li></ul><h2 id="02、Flex布局的思想"><a href="#02、Flex布局的思想" class="headerlink" title="02、Flex布局的思想"></a>02、Flex布局的思想</h2><p>主轴、侧轴</p><p><img src="/2018/08/06/flex/002.png" alt="0"></p><p>​      容器默认存在两根轴：<strong>水平的主轴（main axis）</strong>和<strong>垂直的交叉轴（cross axis）</strong>。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>​    项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h2 id="03-、容器的属性"><a href="#03-、容器的属性" class="headerlink" title="03 、容器的属性"></a>03 、容器的属性</h2><p>常用的有6个属性</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h5 id="1-flexDirection"><a href="#1-flexDirection" class="headerlink" title="1.flexDirection"></a>1.flexDirection</h5><p><code>row | row-reverse | column | column-reverse</code></p><p>  <strong>该属性：规定了主轴的方向（父容器中的排列方向）</strong>。</p><pre><code> row：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。column(默认值)：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。column-reverse：主轴为垂直方向，起点在下沿。</code></pre><p><img src="/2018/08/06/flex/003.png" alt="0"></p><h5 id="2-justifyContent"><a href="#2-justifyContent" class="headerlink" title="2.justifyContent"></a>2.justifyContent</h5><p><strong><code>flex-start | flex-end | center | space-between | space-around</code></strong></p><p><strong>规定：子item在主轴方向的对齐方式</strong></p><pre><code>  flex-start(默认值)：伸缩项目向一行的起始位置靠齐。  flex-end：伸缩项目向一行的结束位置靠齐。  center：伸缩项目向一行的中间位置靠齐。  space-between：两端对齐，项目之间的间隔都相等。  space-around：伸缩项目会平均地分布在行里，两端保留一半的空间。</code></pre><p>  <strong>下图灰色为背景,主轴方向为水平，侧轴方向为垂直</strong>：</p><p><img src="/2018/08/06/flex/004.png" alt="0"></p><h5 id="3-alignItems"><a href="#3-alignItems" class="headerlink" title="3.alignItems"></a>3.alignItems</h5><p><code>flex-start | flex-end | center | baseline | stretch</code></p><p><strong>规定：子item在侧轴方向的对齐方式</strong></p><pre><code>  flex-start：交叉轴的起点对齐。  flex-end：交叉轴的终点对齐 。  center：交叉轴的中点对齐。  baseline：项目的第一行文字的基线对齐。  stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</code></pre><p><strong>下图灰色为背景，主轴方向是水平，侧轴方向是垂直</strong></p><p><img src="/2018/08/06/flex/005.png" alt="0"></p><h5 id="4-flexWrap"><a href="#4-flexWrap" class="headerlink" title="4.flexWrap"></a>4.flexWrap</h5><p><strong><code>nowrap | wrap | wrap-reverse</code></strong></p><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><p><img src="/2018/08/06/flex/006.png" alt="0"></p><p>nowrap(默认值)：不换行。</p><p>![0]flex/007.png)</p><p>wrap：换行，第一行在上方。</p><p><img src="/2018/08/06/flex/008.png" alt="0"></p><p>wrap-reverse：换行，第一行在下方。（和wrap相反）</p><p><img src="/2018/08/06/flex/009.png" alt="0"></p><h2 id="04、元素的属性"><a href="#04、元素的属性" class="headerlink" title="04、元素的属性"></a>04、元素的属性</h2><h5 id="1-flex"><a href="#1-flex" class="headerlink" title="1.flex"></a>1.flex</h5><p>flex是 “flex-grow”、“flex-shrink”和“flex-basis”<a href="http://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">三个属性的缩写</a> , 参数一：定义项目的放大比例；参数二：定义了项目的缩小比例；参数三：定义了在分配多余空间之前，项目占据的主轴空间。其中第二个和第三个参数（flex-shrink、flex-basis）是可选参数。</p><p>flex默认值为“0  1  auto ”。</p><p><img src="/2018/08/06/flex/10.png" alt="0"></p><p>权重分别：1，1，1 和1、3、1</p><h5 id="2-align-self"><a href="#2-align-self" class="headerlink" title="2.align-self"></a>2.align-self</h5><p>align-self属性允许单个item有与其他item不一样的对齐方式</p><pre><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code></pre><p>这个属性没有用过，暂时只做简单了解。</p><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><p>最近又了解到一个新的flex属性，order：弹性元素根据自身order的值来进行排序 </p><pre><code>order:1</code></pre><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。我们可以很容易的给每个伸缩项目设置不同的顺序值。更高的值会排在后面，而原来的HTML结构并不会有任何变化。</p><p>下图就是改变了order属性，默认从左到右容器的排列顺序是A-B-C，通过改变order值，可以调整他们的显示位置。</p><p><img src="/2018/08/06/flex/12.png" alt="0"></p><p>下图是所有的flex属性表，部分属性平时不太常用，平时了解不多，这里也不做过多介绍。感兴趣的小伙伴可以自己去了解哦。</p><p><img src="/2018/08/06/flex/13.png" alt="0"></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>clac的介绍</title>
      <link href="/2018/08/06/calc/"/>
      <url>/2018/08/06/calc/</url>
      
        <content type="html"><![CDATA[<h1 id="一，常用单位"><a href="#一，常用单位" class="headerlink" title="一，常用单位"></a>一，常用单位</h1><p><strong>1、px：</strong>绝对单位，页面按精确像素展示</p><p><strong>2、em：</strong>相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p><p><strong>3、rem：</strong>相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。//（ 是截止目前用的最多也是最流行的）</p><pre><code>  在移动端中利用rem的相对于根HTML进行改变，通过一段JS实现了移动端自适应，本文则使用纯CSS视口单位来自行自适应，虽然现在的兼容性还没法完全能够接受，但不妨碍你认识这个vw和vh的强大。</code></pre><p>​    响应式布局的实现依靠媒体查询（ Media Queries ）来实现，选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配。</p><p>​    即使是通过 rem 单位来实现适配，也是需要内嵌一段脚本去动态计算根元素大小。</p><p>近年来，随着移动端对视口单位的支持越来越成熟、广泛，使得我们可以尝试一种新的办法去真正地适配所有设备尺寸。</p><p>4、百分比（%）</p><p><strong>5、vw、vh、vmin、vmax</strong> 主要用于页面视口大小布局，相对于rem;v*在页面布局上更加方便简单</p><p>​    vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。<br>​    vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。<br>​    vmin：vw和vh中较小的那个。<br>​    vmax：vw和vh中较大的那个。</p><p>兼容性：<strong>vw, vh, vmin, vmax：IE9+局部支持，chrome/firefox/safari/opera支持，ios safari 8+支持，android browser4.4+支持，chrome for android39支持</strong></p><p><img src="/2018/08/06/calc/a1.png" alt="0"></p><h1 id="二、认识视口单位（-Viewport-units"><a href="#二、认识视口单位（-Viewport-units" class="headerlink" title="二、认识视口单位（ Viewport units )"></a>二、认识视口单位（ Viewport units )</h1><p>​    在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；</p><pre><code>  而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。</code></pre><p>​    而视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。</p><p><img src="/2018/08/06/calc/a2.jpg" alt="0"></p><p>根据CSS3规范，视口单位主要包括以下4个：<a href="http://caibaojian.com/vw-vh.html" target="_blank" rel="noopener">·</a></p><ul><li>vw : 1vw 等于视口宽度的1%</li><li>vh : 1vh 等于视口高度的1%</li><li>vmin : 选取 vw 和 vh 中最小的那个</li><li>vmax : 选取 vw 和 vh 中最大的那个</li></ul><p><strong>视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。</strong><img src="/2018/08/06/calc/a3.jpg" alt="0"></p><p>用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况）</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>媒体查询</title>
      <link href="/2018/07/29/meiti/"/>
      <url>/2018/07/29/meiti/</url>
      
        <content type="html"><![CDATA[<h1 id="一、媒体查询用法"><a href="#一、媒体查询用法" class="headerlink" title="一、媒体查询用法"></a>一、媒体查询用法</h1><p> @media 媒体查询包含一个可选的<a href="https://developer.mozilla.org/en-US/docs/CSS/@media" target="_blank" rel="noopener">媒体类型</a>和，满足CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true.</p><p>　　(1)500px-800px之间的设备 <code>@media screen and (min-width: 500px) and (max-width: 800px) { ... }</code></p><p>​       (2)最小宽度500  @media screen and (min-width: 500px){… }</p><p>　　(3)在非打印设备下 @media not print and (max-width: 1200px)</p><h1 id="二、常见的媒体查询尺寸"><a href="#二、常见的媒体查询尺寸" class="headerlink" title="二、常见的媒体查询尺寸"></a>二、常见的媒体查询尺寸</h1><p>@media screen and (min-width:1200px)</p><p>@media screen and (min-width:992px)</p><p>@media screen and (min-width:768px)</p><p>@media screen and (min-width:480px)</p><p>在设置时，需要注意先后顺序，不然后面的会覆盖前面的样式。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/20/hello-world/"/>
      <url>/2018/06/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
